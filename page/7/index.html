<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 7 页 | WiZero</title>
  <meta name="author" content="Wlin">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="WiZero"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  <link rel="alternate" href="/hexo_blog/atom.xml" title="WiZero" type="application/atom+xml">
  <link rel="stylesheet" href="/hexo_blog/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <meta name="wumiiVerification" content="fb50a101-84fe-4ca2-91a7-ae8cf792978b" />
  
  <meta name="wumiiVerification" content="d73b5866-c390-4156-a4dd-51b526b5335e" />
</head>

<body>
  <header id="header">
<div class= "header-content inner">
	<div class = "alignleft col-one">
		
			<div class='avatar'>
				<img src = "/hexo_blog/images/site/lufy-avatar.jpg">
              </div>
		
		<div class="header-div">
		    <h1><a href="/hexo_blog/">WiZero</a></h1>
		    <h2><a href="/hexo_blog/">阅读，思考，实践，不忘初心</a></h2>
		</div>
	</div>
	<div class = "alignright col-two">
		
	</div>
	<div class="clearfix"></div>
</div>

<div class= "header-nav">
	<div class='header-nav-content inner'>
		<div id="main-nav" class="alignleft">
			<ul>
		    		
		    		  <li><a href="/hexo_blog/./">首页</a></li>
		    		
		    		  <li><a href="/hexo_blog/archives">归档</a></li>
		    		
		    	</ul>
		</div>
		<div id="sub-nav" class="alignright">
     	 <ul>
		    
		      <li><a href="/hexo_blog/atom.xml">订阅</a></li>
		    
		      <li><a href="/hexo_blog/customization">留言</a></li>
		    
     	 </ul>
		</div>
	</div>
	<div class="clearfix"></div>
</div>
</header>
  
    <div id="content" class="inner">
      <div id="main-col" class="alignleft"><div id="wrapper">
	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#logging-参数"><span class="toc-number">1.1.</span> <span class="toc-text">logging 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logging输出到不同地方"><span class="toc-number">1.2.</span> <span class="toc-text">logging输出到不同地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logging-handle-方式"><span class="toc-number">1.3.</span> <span class="toc-text">logging handle 方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logging-config模块"><span class="toc-number">1.4.</span> <span class="toc-text">logging.config模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lib"><span class="toc-number">2.</span> <span class="toc-text">Lib</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#logging-getLogger-name-None"><span class="toc-number">2.1.</span> <span class="toc-text">logging.getLogger(name=None)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler-object"><span class="toc-number">2.2.</span> <span class="toc-text">Handler object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logging-Formatter"><span class="toc-number">2.3.</span> <span class="toc-text">logging.Formatter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-Link"><span class="toc-number">3.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-21T15:55:37.000Z"><a href="/hexo_blog/2016/01/21/Python-Basic-2016-01-27-python-basic-log/">2016-01-21</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/21/Python-Basic-2016-01-27-python-basic-log/">python-basic~loging调试监控</a></h1>
  

    </header>

    <div class="entry">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>允许你指定记录信息的级别，有</p>
<ul>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
</ul>
<p>日志级别大小关系为：CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET，当然也可以自己定义日志级别</p>
<p>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/hexo_blog/2016/01/21/Python-Basic-2016-01-27-python-basic-log/#more" class="more-link">Read More</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	

	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一"><span class="toc-number">1.</span> <span class="toc-text">(一)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二"><span class="toc-number">2.</span> <span class="toc-text">(二)</span></a></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-21T15:55:37.000Z"><a href="/hexo_blog/2016/01/21/Python-Basic-2016-01-21-python-basic-unittest单元测试-zt/">2016-01-21</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/21/Python-Basic-2016-01-21-python-basic-unittest单元测试-zt/">python-basic~unittest单元测试-zt</a></h1>
  

    </header>

    <div class="entry">
      
          <!--
       
              <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一"><span class="toc-number">1.</span> <span class="toc-text">(一)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二"><span class="toc-number">2.</span> <span class="toc-text">(二)</span></a></li></ol>
</div>

                  

                  -->
        <p>转载：<a href="http://kingname.info/2015/03/04/pythonunittest1/" target="_blank" rel="external">Python的单元测试（一）</a><br>转载：<a href="http://kingname.info/2015/03/04/pythonunittest2/" target="_blank" rel="external">Python的单元测试（二）</a></p>
<h3 id="一"><a href="#一" class="headerlink" title="(一)"></a>(一)</h3><p>测试驱动的软件开发方式可以强迫程序员在开发程序的时候使程序的函数之间实现高内聚，低耦合。这样的方式可以降低函数之间的依赖性，方便后续的修改，增加功能和维护。</p>
<p>说一个函数高内聚，就是指这个函数专注于实现单一的任务，不会做除了生产这个任务以外的其他事情。可以想象一个人，他把自己关在一个小房子里面生产东西，只留两扇窗户，他需要什么材料，你就从小窗户给他送进去（参数），他做好了东西，就给你从另一个窗户里面送出来（return），他不会说，我要生产一个轮子，但是我首先需要一个女人进来，他不会说，这是计划的一部分。</p>
<p>说几个函数是低耦合的，就是指他们的依赖性小。他们就像是葫芦娃，每个都有自己独特的能力，可以自己单干，在关键的时候还可以合体，变成小金刚。他们就像积木一样，各有各的功能，需要使用的时候直接组合在一起就可以了。</p>
<p>使用测试驱动开发，每一个测试只测试一个功能，这样就可以迫使函数把自己独立出来，尽量减少和其他函数的依赖。</p>
<p>例如，有一个文件1.txt，他的内容是两个数字，使用逗号隔开。形如“2,4”（不包括外侧双引号，下同）。我要写一个程序readandadd.py，读取硬盘上的1.txt文件，然后把这个文件的内容打印到屏幕上。</p>
<p>不规范的写法一：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">f= open(<span class="string">'1.txt'</span>,<span class="string">'r'</span>)</div><div class="line">b = f.read().split(<span class="string">','</span>)</div><div class="line">f.close()</div><div class="line"><span class="keyword">print</span> int(b[<span class="number">0</span>])+int(b[<span class="number">1</span>])</div></pre></td></tr></table></figure></p>
<p>不规范写法二：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></div><div class="line">    f= open(<span class="string">'1.txt'</span>,<span class="string">'r'</span>)</div><div class="line">    b = f.read().split(<span class="string">','</span>)</div><div class="line">    f.close()</div><div class="line">    <span class="keyword">print</span> int(b[<span class="number">0</span>])+int(b[<span class="number">1</span>])</div><div class="line">A()</div></pre></td></tr></table></figure></p>
<p>比较规范的写法：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(filename)</span>:</span></div><div class="line">    f= open(filename,<span class="string">'r'</span>)</div><div class="line">    info = f.read()</div><div class="line">    f.close()</div><div class="line">    <span class="keyword">return</span> info</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getnum</span><span class="params">(info)</span>:</span></div><div class="line">    twonum = info.split(<span class="string">','</span>)</div><div class="line">    <span class="keyword">return</span> twonum</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnum</span><span class="params">(twonum)</span>:</span></div><div class="line">    <span class="keyword">return</span> int(twonum[<span class="number">0</span>])+int(twonum[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">        info = read(<span class="string">'1.txt'</span>)</div><div class="line">        twonum = getnum(info)</div><div class="line">        result = addnum(twonum)</div><div class="line">        <span class="keyword">print</span> result</div></pre></td></tr></table></figure></p>
<p>这样写的好处是，如果想测试读文件的功能，就只需要测试read()函数，如果想测试把两个数分开的功能，就只需要测试getnum()函数。而相反，在不规范写法二中，虽然只想测试两个数字相加的功能，可是却不得不首先打开文件并读取文件然后把数字分开。</p>
<p>继续回到比较规范的写法当中，我相信很多人写完read()函数以后，肯定会输入如下代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(filename)</span>:</span></div><div class="line">    f= open(filename,<span class="string">'r'</span>)</div><div class="line">    info = f.read()</div><div class="line">    f.close()</div><div class="line">    <span class="keyword">return</span> info</div><div class="line"></div><div class="line"><span class="keyword">print</span> read(<span class="string">'1.txt'</span>)</div></pre></td></tr></table></figure></p>
<p>然后运行程序，发现正常打印出’2,3’以后，再开始写getnum()函数。写完getnum以后，测试getnum()函数没问题以后再开始写然后测试addnum()函数。最后测试整个程序的功能。</p>
<p>其实这个过程，已经就是在做单元测试了。然而这样操作的弊端是什么？如果整体程序已经写好了，之前做测试点代码也就删除了。那么如果突然把程序做了修改。例如1.txt里面数字的分隔从1个逗号变成了空格，或者变成了3个数字，那必然要修改getnum()，但是又如何测试修改的部分呢？还要把不相干的代码给注释掉。不仅麻烦，而且容易出错。</p>
<p>现在，把测试的代码单独独立出来。会有什么效果呢？尝试创建一个test.py程序，代码如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> readandadd</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testread</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'read:'</span>,readandadd.read(<span class="string">'1.txt'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testgetnum</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'getnum:'</span>,readandadd.getnum(<span class="string">'2,3'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testaddnum</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'addnum:'</span>,readandadd.addnum([<span class="number">2</span>,<span class="number">3</span>])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    testread()</div><div class="line">    testgetnum()</div><div class="line">    testaddnum()</div></pre></td></tr></table></figure></p>
<p>运行test.py以后输出结果如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">read: <span class="number">2</span>,<span class="number">3</span></div><div class="line">getnum: [<span class="string">'2'</span>, <span class="string">'3'</span>]</div><div class="line">addnum: <span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>每一个函数的输出结果一目了然，而且在修改了readandadd.py的函数以后，重新运行test.py就可以知道输出结果有没有符合预期。</p>
<p>当然，这里这个例子非常的简单，因此可以人工通过观察test.py的输出结果来确定是否符合预期，那对于大量的函数的测试，难道也要让肉眼来看吗？当然不是。于是，下一篇文章将会介绍Python的单元测试<code>unittest</code>。</p>
<h3 id="二"><a href="#二" class="headerlink" title="(二)"></a>(二)</h3><p>在这个例子中，只有三个函数，于是可以把每个函数的输出结果打印到屏幕上，再用肉眼去看结果是否符合预期。然而假设有一个程序，有二十个类，每个类又有几十个函数，有些函数的输出结果还多达几十行，在这种情况下，肉眼如何看得出？</p>
<p>当然你可以使用if判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> 输出结果 == 预期结果:</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">u'不相等'</span></div></pre></td></tr></table></figure>
<p>这个时候，你发现，程序有几个函数，后三行就要重复几次，本着代码简洁的原则，你把这个判断的过程写到一个函数中：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">isequal</span><span class="params">(output,right_output)</span>:</span></div><div class="line">    <span class="keyword">if</span> output == right_output:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">u'不相等'</span></div></pre></td></tr></table></figure></p>
<p>那么恭喜你，你步入正规了，然而，这一切已经有人为你做好了。欢迎unittest模块出场。</p>
<blockquote>
<blockquote>
<p>unittest supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework. The unittest module provides classes that make it easy to support these qualities for a set of tests.</p>
</blockquote>
</blockquote>
<p>Python的官方文档这样写到，unittest支持自动化测试，测试的安装分享和关闭代码……</p>
<p>一句话说来，就是，unittest很好用。</p>
<p>还是用上一次的readandadd.py来演示unittest的基本用法,首先介绍unittest的一个函数，assertEqual(first,second),这个函数的作用是检查变量first的值与second的值是否相等，如果不相等就抛出错误。</p>
<p>先创建utest.py文件，输入以下代码并运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#-*-coding:utf-8-*-</span></div><div class="line"><span class="keyword">import</span> unittest</div><div class="line"><span class="keyword">import</span> readandadd</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">basictest</span><span class="params">(unittest.TestCase)</span>:</span> <span class="comment">#类名可以随便取</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testread</span><span class="params">(self)</span>:</span> <span class="comment">#每个函数都要以test开头</span></div><div class="line">        output = readandadd.read(<span class="string">'1.txt'</span>)</div><div class="line">        self.assertEqual(output,<span class="string">'2,3'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testgetnum</span><span class="params">(self)</span>:</span></div><div class="line">        output = readandadd.getnum(<span class="string">'2,3'</span>)</div><div class="line">        self.assertEqual(output,[<span class="string">'2'</span>, <span class="string">'3'</span>])</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testaddnum</span><span class="params">(self)</span>:</span></div><div class="line">        output = readandadd.addnum([<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">        self.assertEqual(output,<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    unittest.main()</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">...</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">3</span> tests <span class="keyword">in</span> <span class="number">0.001</span>s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure>
<p>你也许会说，就一个ok，什么都没有啊。那我先把testread()函数下面的<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">self.assertEqual(output,<span class="string">'2,3'</span>)</div></pre></td></tr></table></figure></p>
<p>改为<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">self.assertEqual(output,<span class="string">'2,4'</span>)</div></pre></td></tr></table></figure></p>
<p>在运行utest.py看看输出结果如何：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">..F</div><div class="line">======================================================================</div><div class="line">FAIL: testread (__main__.basictest)</div><div class="line">----------------------------------------------------------------------</div><div class="line">Traceback (most recent call last):</div><div class="line">    File <span class="string">"E:/mystuff/unitest/utest.py"</span>, line <span class="number">8</span>, <span class="keyword">in</span> testread</div><div class="line">    self.assertEqual(output,<span class="string">'2,4'</span>)</div><div class="line">AssertionError: <span class="string">'2,3'</span> != <span class="string">'2,4'</span></div><div class="line"></div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">3</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</div><div class="line"></div><div class="line">FAILED (failures=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>这里准确的找出了错误的位置和错误的具体内容。注意看最上面，有个</p>
<pre><code>..F
</code></pre><p>猜测它可能是标示错误的位置。保持testread的错误不改，再把testgetnum()函数中的以下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">self.assertEqual(output,[<span class="string">'2'</span>, <span class="string">'3'</span>])</div></pre></td></tr></table></figure>
<p>改为<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">self.assertEqual(output,[<span class="string">'2'</span>, <span class="string">'6'</span>])</div></pre></td></tr></table></figure></p>
<p>再运行utest.py程序，输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">.FF</div><div class="line">======================================================================</div><div class="line">FAIL: testgetnum (__main__.basictest)</div><div class="line">----------------------------------------------------------------------</div><div class="line">Traceback (most recent call last):</div><div class="line">    File "E:/mystuff/unitest/utest.py", line 12, in testgetnum</div><div class="line">    self.assertEqual(output,['2', '6'])</div><div class="line">AssertionError: Lists differ: ['2', '3'] != ['2', '6']</div><div class="line"></div><div class="line">First differing element 1:</div><div class="line">3</div><div class="line">6</div><div class="line"></div><div class="line">- ['2', '3']</div><div class="line">?        ^</div><div class="line"></div><div class="line">+ ['2', '6']</div><div class="line">?        ^</div><div class="line"></div><div class="line"></div><div class="line">======================================================================</div><div class="line">FAIL: testread (__main__.basictest)</div><div class="line">----------------------------------------------------------------------</div><div class="line">Traceback (most recent call last):</div><div class="line">    File "E:/mystuff/unitest/utest.py", line 8, in testread</div><div class="line">    self.assertEqual(output,'2,4')</div><div class="line">AssertionError: '2,3' != '2,4'</div><div class="line"></div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran 3 tests in 0.001s</div><div class="line"></div><div class="line">FAILED (failures=2)</div></pre></td></tr></table></figure>
<p>可以看出，这里分别把两个错误显示了出来。并且第一行变成了<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">.FF</div></pre></td></tr></table></figure></p>
<p>所以，第一行的内容应该从右往左读，它标明错误函数在所有函数的相对位置。</p>
<p>现在再把testread()和testgetnum()改回去，再看看全部正确的输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">...</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">3</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure>
<p>印证了那句话，没有消息就是最好的消息。</p>
<p>这篇文章介绍了单元测试模块unittest的assertEqual的基本用法</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	

	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-格式化-format-输出字符串-详解-及-代码"><span class="toc-number">1.</span> <span class="toc-text">Python - 格式化(format())输出字符串 详解 及 代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-Link"><span class="toc-number">2.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-20T01:21:05.000Z"><a href="/hexo_blog/2016/01/20/Python-Basic-2016-01-20-python-basic-string-advanced/">2016-01-20</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/20/Python-Basic-2016-01-20-python-basic-string-advanced/">python-basic~string-字符串的进阶</a></h1>
  

    </header>

    <div class="entry">
      
          <!--
       
              <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-格式化-format-输出字符串-详解-及-代码"><span class="toc-number">1.</span> <span class="toc-text">Python - 格式化(format())输出字符串 详解 及 代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-Link"><span class="toc-number">2.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

                  

                  -->
        <h2 id="Python-格式化-format-输出字符串-详解-及-代码"><a href="#Python-格式化-format-输出字符串-详解-及-代码" class="headerlink" title="Python - 格式化(format())输出字符串 详解 及 代码"></a>Python - 格式化(format())输出字符串 详解 及 代码</h2><p>出处：<a href="http://blog.csdn.net/caroline_wendy/article/details/17111451" target="_blank" rel="external">Python - 格式化(format())输出字符串 详解 及 代码</a></p>
<p>Python中格式化输出字符串使用<code>format()</code>函数, 字符串即类, 可以使用方法;</p>
<p>Python是完全面向对象的语言, 任何东西都是对象;</p>
<p>字符串的参数使用<code>{NUM}</code>进行表示,</p>
<p>0, 表示第一个参数,1, 表示第二个参数, 以后顺次递加;</p>
<p>使用”:”, 指定代表元素需要的操作, 如”<code>:.3</code>“小数点三位, “<code>:8</code>“占8个字符空间等;<br>还可以添加特定的字母, 如:</p>
<ul>
<li>‘b’ - 二进制. 将数字以2为基数进行输出.</li>
<li>‘c’ - 字符. 在打印之前将整数转换成对应的Unicode字符串.</li>
<li>‘d’ - 十进制整数. 将数字以10为基数进行输出.</li>
<li>‘o’ - 八进制. 将数字以8为基数进行输出. </li>
<li>‘x’ - 十六进制. 将数字以16为基数进行输出, 9以上的位数用小写字母.</li>
<li>‘e’ - 幂符号. 用科学计数法打印数字, 用’e’表示幂. </li>
<li>‘g’ - 一般格式. 将数值以fixed-point格式输出. 当数值特别大的时候, 用幂形式打印. </li>
<li>‘n’ - 数字. 当值为整数时和’d’相同, 值为浮点数时和’g’相同. 不同的是它会根据区域设置插入数字分隔符. </li>
<li>‘%’ - 百分数. 将数值乘以100然后以fixed-point(‘f’)格式打印, 值后面会有一个百分号. </li>
</ul>
<p>数字(0, 1, …)即代表format()里面的元素, 所以可以使用”.”调用元素的方法;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></div><div class="line"><span class="comment">#====================  </span></div><div class="line"><span class="comment">#File: abop.py  </span></div><div class="line"><span class="comment">#Author: Wendy  </span></div><div class="line"><span class="comment">#Date: 2013-12-03  </span></div><div class="line"><span class="comment">#====================  </span></div><div class="line"><span class="comment">#eclipse pydev, python3.3  </span></div><div class="line">age = <span class="number">25</span>  </div><div class="line">name = <span class="string">'Caroline'</span>  </div><div class="line">  </div><div class="line">print(<span class="string">'&#123;0&#125; is &#123;1&#125; years old. '</span>.format(name, age)) <span class="comment">#输出参数  </span></div><div class="line">print(<span class="string">'&#123;0&#125; is a girl. '</span>.format(name))  </div><div class="line">print(<span class="string">'&#123;0:.3&#125; is a decimal. '</span>.format(<span class="number">1</span>/<span class="number">3</span>)) <span class="comment">#小数点后三位  </span></div><div class="line">print(<span class="string">'&#123;0:_^11&#125; is a 11 length. '</span>.format(name)) <span class="comment">#使用_补齐空位  </span></div><div class="line">print(<span class="string">'&#123;first&#125; is as &#123;second&#125;. '</span>.format(first=name, second=<span class="string">'Wendy'</span>)) <span class="comment">#别名替换  </span></div><div class="line">print(<span class="string">'My name is &#123;0.name&#125;'</span>.format(open(<span class="string">'out.txt'</span>, <span class="string">'w'</span>))) <span class="comment">#调用方法  </span></div><div class="line">print(<span class="string">'My name is &#123;0:8&#125;.'</span>.format(<span class="string">'Fred'</span>)) <span class="comment">#指定宽度</span></div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Caroline is 25 years old.   </div><div class="line">Caroline is a girl.   </div><div class="line">0.333 is a decimal.   </div><div class="line">_Caroline__ is a 11 length.   </div><div class="line">Caroline is as Wendy.   </div><div class="line">My name is out.txt  </div><div class="line">My name is Fred    .</div></pre></td></tr></table></figure></p>
<h2 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h2>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	

	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#会话对象-Session"><span class="toc-number">1.</span> <span class="toc-text">会话对象 Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保持活动状态（持久连接）"><span class="toc-number">2.</span> <span class="toc-text">保持活动状态（持久连接）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求与响应对象-header"><span class="toc-number">3.</span> <span class="toc-text">请求与响应对象 header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应内容的编码方式"><span class="toc-number">4.</span> <span class="toc-text">响应内容的编码方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理"><span class="toc-number">5.</span> <span class="toc-text">代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP动词"><span class="toc-number">6.</span> <span class="toc-text">HTTP动词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-Link"><span class="toc-number">7.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-17T07:41:37.000Z"><a href="/hexo_blog/2016/01/17/Python-Basic-2016-01-17-python-basic-requests-高级用法/">2016-01-17</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/17/Python-Basic-2016-01-17-python-basic-requests-高级用法/">python-basic~requests-高级用法</a></h1>
  

    </header>

    <div class="entry">
      
          <!--
       
              <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#会话对象-Session"><span class="toc-number">1.</span> <span class="toc-text">会话对象 Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保持活动状态（持久连接）"><span class="toc-number">2.</span> <span class="toc-text">保持活动状态（持久连接）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求与响应对象-header"><span class="toc-number">3.</span> <span class="toc-text">请求与响应对象 header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应内容的编码方式"><span class="toc-number">4.</span> <span class="toc-text">响应内容的编码方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代理"><span class="toc-number">5.</span> <span class="toc-text">代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP动词"><span class="toc-number">6.</span> <span class="toc-text">HTTP动词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-Link"><span class="toc-number">7.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

                  

                  -->
        <h2 id="会话对象-Session"><a href="#会话对象-Session" class="headerlink" title="会话对象 Session"></a>会话对象 Session</h2><p>会话对象让你能够跨请求保持某些参数。它也<strong>会在同一个Session实例发出的所有请求之间保持cookies</strong>。</p>
<p>会话对象具有主要的Requests API的所有方法。</p>
<p>我们来跨请求保持一些cookies:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">s = requests.Session()</div><div class="line"></div><div class="line">s.get(&apos;http://httpbin.org/cookies/set/sessioncookie/123456789&apos;)</div><div class="line">r = s.get(&quot;http://httpbin.org/cookies&quot;)</div><div class="line"></div><div class="line">print(r.text)</div><div class="line"># &apos;&#123;&quot;cookies&quot;: &#123;&quot;sessioncookie&quot;: &quot;123456789&quot;&#125;&#125;&apos;</div></pre></td></tr></table></figure>
<p>会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">s = requests.Session()</div><div class="line">s.auth = (&apos;user&apos;, &apos;pass&apos;)</div><div class="line">s.headers.update(&#123;&apos;x-test&apos;: &apos;true&apos;&#125;)</div><div class="line"></div><div class="line"># both &apos;x-test&apos; and &apos;x-test2&apos; are sent</div><div class="line">s.get(&apos;http://httpbin.org/headers&apos;, headers=&#123;&apos;x-test2&apos;: &apos;true&apos;&#125;)</div></pre></td></tr></table></figure>
<p>任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。</p>
<p>从字典参数中移除一个值<br>有时你会想省略字典参数中一些会话层的键。要做到这一点，你只需简单地在方法层参数中将那个键的值设置为 None ，那个键就会被自动省略掉。</p>
<p>包含在一个会话中的所有数据你都可以直接使用。</p>
<h2 id="保持活动状态（持久连接）"><a href="#保持活动状态（持久连接）" class="headerlink" title="保持活动状态（持久连接）"></a>保持活动状态（持久连接）</h2><p>归功于<code>urllib3</code>，同一会话内的持久连接是完全自动处理的！同一会话内你发出的任何请求都会自动复用恰当的连接！</p>
<p>注意：只有所有的响应体数据被读取完毕连接才会被释放为连接池；所以确保将 stream 设置为 False 或读取 Response 对象的 content 属性。</p>
<h2 id="请求与响应对象-header"><a href="#请求与响应对象-header" class="headerlink" title="请求与响应对象 header"></a>请求与响应对象 header</h2><p>任何时候调用<code>requests.*()</code>你都在做两件主要的事情。其一，你在构建一个 Request 对象， 该对象将被发送到某个服务器请求或查询一些资源。其二，一旦 requests 得到一个从 服务器返回的响应就会产生一个 Response 对象。该响应对象包含服务器返回的所有信息， 也包含你原来创建的 Request 对象。如下是一个简单的请求，从Wikipedia的服务器得到 一些非常重要的信息:</p>
<pre><code>&gt;&gt;&gt; r = requests.get(&apos;http://en.wikipedia.org/wiki/Monty_Python&apos;)
</code></pre><p>如果想访问服务器返回给我们的响应头部信息，可以这样做:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; r.headers</div><div class="line">&#123;&apos;content-length&apos;: &apos;56170&apos;, &apos;x-content-type-options&apos;: &apos;nosniff&apos;, &apos;x-cache&apos;:</div><div class="line">&apos;HIT from cp1006.eqiad.wmnet, MISS from cp1010.eqiad.wmnet&apos;, &apos;content-encoding&apos;:</div><div class="line">&apos;gzip&apos;, &apos;age&apos;: &apos;3080&apos;, &apos;content-language&apos;: &apos;en&apos;, &apos;vary&apos;: &apos;Accept-Encoding,Cookie&apos;,</div><div class="line">&apos;server&apos;: &apos;Apache&apos;, &apos;last-modified&apos;: &apos;Wed, 13 Jun 2012 01:33:50 GMT&apos;,</div><div class="line">&apos;connection&apos;: &apos;close&apos;, &apos;cache-control&apos;: &apos;private, s-maxage=0, max-age=0,</div><div class="line">must-revalidate&apos;, &apos;date&apos;: &apos;Thu, 14 Jun 2012 12:59:39 GMT&apos;, &apos;content-type&apos;:</div><div class="line">&apos;text/html; charset=UTF-8&apos;, &apos;x-cache-lookup&apos;: &apos;HIT from cp1006.eqiad.wmnet:3128,</div><div class="line">MISS from cp1010.eqiad.wmnet:80&apos;&#125;</div></pre></td></tr></table></figure>
<p>然而，如果想得到发送到服务器的请求的头部，我们可以简单地访问该请求，然后是该请求的头部:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; r.request.headers</div><div class="line">&#123;&apos;Accept-Encoding&apos;: &apos;identity, deflate, compress, gzip&apos;,</div><div class="line">&apos;Accept&apos;: &apos;*/*&apos;, &apos;User-Agent&apos;: &apos;python-requests/0.13.1&apos;&#125;</div></pre></td></tr></table></figure>
<h2 id="响应内容的编码方式"><a href="#响应内容的编码方式" class="headerlink" title="响应内容的编码方式"></a>响应内容的编码方式</h2><p>当你收到一个响应时，Requests会猜测响应的编码方式，<strong>用于在你调用 Response.text 方法时对响应进行解码</strong>。</p>
<p>Requests首先在HTTP头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。</p>
<p>只有当HTTP头部不存在明确指定的字符集，并且 Content-Type 头部字段包含 text 值之时， Requests才不去猜测编码方式。</p>
<p>在这种情况下， RFC 2616 指定默认字符集 必须是 <code>ISO-8859-1</code> 。Requests遵从这一规范。<br><strong>如果你需要一种不同的编码方式，你可以手动设置 Response.encoding 属性，或使用原始的 Response.content</strong> 。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    import requests</div><div class="line">    </div><div class="line">    proxies = &#123;</div><div class="line">      &quot;http&quot;: &quot;http://10.10.1.10:3128&quot;,</div><div class="line">      &quot;https&quot;: &quot;http://10.10.1.10:1080&quot;,</div><div class="line">    &#125;</div><div class="line">requests.get(&quot;http://example.org&quot;, proxies=proxies)</div></pre></td></tr></table></figure></p>
<p>你也可以通过环境变量 <code>HTTP_PROXY</code> 和 <code>HTTPS_PROXY</code> 来配置代理。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ export HTTP_PROXY=&quot;http://10.10.1.10:3128&quot;</div><div class="line">$ export HTTPS_PROXY=&quot;http://10.10.1.10:1080&quot;</div><div class="line">$ python</div><div class="line">&gt;&gt;&gt; import requests</div><div class="line">&gt;&gt;&gt; requests.get(&quot;http://example.org&quot;)</div></pre></td></tr></table></figure></p>
<p>若你的代理需要使用HTTP Basic Auth，可以使用 <code>http://user:password@host/</code> 语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">proxies = &#123;</div><div class="line">    &quot;http&quot;: &quot;http://user:pass@10.10.1.10:3128/&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>Requests提供了几乎所有HTTP动词的功能：GET，OPTIONS， HEAD，POST，PUT，PATCH和DELETE。 以下内容为使用Requests中的这些动词以及Github API提供了详细示例。</p>
<p>我将从最常使用的动词GET开始。HTTP GET是一个幂等的方法，从给定的URL返回一个资源。因而， 当你试图从一个web位置获取数据之时，你应该使用这个动词。<strong>一个使用示例是尝试从Github上获取关于一个特定commit的信息</strong>。</p>
<p>假设我们想获取Requests的commit a050faf 的信息。我们可以 这样去做:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; import requests</div><div class="line">&gt;&gt;&gt; r = requests.get(&apos;https://api.github.com/repos/kennethreitz/requests/git/commits/a050faf084662f3a352dd1a941f2c7c9f886d4ad&apos;)</div></pre></td></tr></table></figure></p>
<p>我们应该确认Github是否正确响应。如果正确响应，我们想弄清响应内容是什么类型的。像这样去做:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; if (r.status_code == requests.codes.ok):</div><div class="line">...     print r.headers[&apos;content-type&apos;]</div><div class="line">...</div><div class="line">application/json; charset=utf-8</div></pre></td></tr></table></figure></p>
<p>可见，<strong>GitHub返回了JSON数据</strong>，非常好，这样就可以使用 <code>r.json</code> 方法把这个返回的数据解析成Python对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; commit_data = r.json()</div><div class="line">&gt;&gt;&gt; print commit_data.keys()</div><div class="line">[u&apos;committer&apos;, u&apos;author&apos;, u&apos;url&apos;, u&apos;tree&apos;, u&apos;sha&apos;, u&apos;parents&apos;, u&apos;message&apos;]</div><div class="line">&gt;&gt;&gt; print commit_data[u&apos;committer&apos;]</div><div class="line">&#123;u&apos;date&apos;: u&apos;2012-05-10T11:10:50-07:00&apos;, u&apos;email&apos;: u&apos;me@kennethreitz.com&apos;, u&apos;name&apos;: u&apos;Kenneth Reitz&apos;&#125;</div><div class="line">&gt;&gt;&gt; print commit_data[u&apos;message&apos;]</div><div class="line">makin&apos; history</div></pre></td></tr></table></figure></p>
<p>到目前为止，一切都非常简单。嗯，我们来研究一下GitHub的API。我们可以去看看文档， 但如果使用Requests来研究也许会更有意思一点。我们可以借助Requests的OPTIONS动词来看看我们刚使用过的url 支持哪些HTTP方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; verbs = requests.options(r.url)</div><div class="line">&gt;&gt;&gt; verbs.status_code</div><div class="line">500</div></pre></td></tr></table></figure></p>
<p>额，这是怎么回事？毫无帮助嘛！原来GitHub，与许多API提供方一样，实际上并未实现OPTIONS方法。 这是一个恼人的疏忽，但没关系，那我们可以使用枯燥的文档。然而，<strong>如果GitHub正确实现了OPTIONS， 那么服务器应该在响应头中返回允许用户使用的HTTP方法</strong>，例如<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; verbs = requests.options(&apos;http://a-good-website.com/api/cats&apos;)</div><div class="line">&gt;&gt;&gt; print verbs.headers[&apos;allow&apos;]</div><div class="line">GET,HEAD,POST,OPTIONS</div></pre></td></tr></table></figure></p>
<p>转而去查看文档，我们看到对于提交信息，另一个允许的方法是POST，它会创建一个新的提交。<br>由于我们正在使用Requests代码库，我们应尽可能避免对它发送笨拙的POST。作为替代，我们来 玩玩GitHub的Issue特性。</p>
<p>本篇文档是回应Issue #482而添加的。鉴于该问题已经存在，我们就以它为例。先获取它。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; r = requests.get(&apos;https://api.github.com/repos/kennethreitz/requests/issues/482&apos;)</div><div class="line">&gt;&gt;&gt; r.status_code</div><div class="line">200</div><div class="line">&gt;&gt;&gt; issue = json.loads(r.text)</div><div class="line">&gt;&gt;&gt; print issue[u&apos;title&apos;]</div><div class="line">Feature any http verb in docs</div><div class="line">&gt;&gt;&gt; print issue[u&apos;comments&apos;]</div><div class="line">3</div></pre></td></tr></table></figure></p>
<p>Cool，有3个评论。我们来看一下最后一个评论。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; r = requests.get(r.url + u&apos;/comments&apos;)</div><div class="line">&gt;&gt;&gt; r.status_code</div><div class="line">200</div><div class="line">&gt;&gt;&gt; comments = r.json()</div><div class="line">&gt;&gt;&gt; print comments[0].keys()</div><div class="line">[u&apos;body&apos;, u&apos;url&apos;, u&apos;created_at&apos;, u&apos;updated_at&apos;, u&apos;user&apos;, u&apos;id&apos;]</div><div class="line">&gt;&gt;&gt; print comments[2][u&apos;body&apos;]</div><div class="line">Probably in the &quot;advanced&quot; section</div></pre></td></tr></table></figure></p>
<p>嗯，那看起来似乎是个愚蠢之处。我们发表个评论来告诉这个评论者他自己的愚蠢。那么，这个评论者是谁呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; print comments[2][u&apos;user&apos;][u&apos;login&apos;]</div><div class="line">kennethreitz</div></pre></td></tr></table></figure></p>
<p>好，我们来告诉这个叫肯尼思的家伙，这个例子应该放在快速上手指南中。根据GitHub API文档， 其方法是POST到该话题。我们来试试看。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; body = json.dumps(&#123;u&quot;body&quot;: u&quot;Sounds great! I&apos;ll get right on it!&quot;&#125;)</div><div class="line">&gt;&gt;&gt; url = u&quot;https://api.github.com/repos/kennethreitz/requests/issues/482/comments&quot;</div><div class="line">&gt;&gt;&gt; r = requests.post(url=url, data=body)</div><div class="line">&gt;&gt;&gt; r.status_code</div><div class="line">404</div></pre></td></tr></table></figure></p>
<p>额，这有点古怪哈。可能我们需要验证身份。那就有点纠结了，对吧？不对。Requests简化了多种身份验证形式的使用， 包括非常常见的Basic Auth。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; from requests.auth import HTTPBasicAuth</div><div class="line">&gt;&gt;&gt; auth = HTTPBasicAuth(&apos;fake@example.com&apos;, &apos;not_a_real_password&apos;)</div><div class="line">&gt;&gt;&gt; r = requests.post(url=url, data=body, auth=auth)</div><div class="line">&gt;&gt;&gt; r.status_code</div><div class="line">201</div><div class="line">&gt;&gt;&gt; content = r.json()</div><div class="line">&gt;&gt;&gt; print(content[u&apos;body&apos;])</div><div class="line">Sounds great! I&apos;ll get right on it.</div></pre></td></tr></table></figure></p>
<p>精彩！噢，不！我原本是想说等我一会，因为我得去喂一下我的猫。如果我能够编辑这条评论那就好了！ 幸运的是，GitHub允许我们使用另一个HTTP动词，PATCH，来编辑评论。我们来试试。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; print(content[u&quot;id&quot;])</div><div class="line">5804413</div><div class="line">&gt;&gt;&gt; body = json.dumps(&#123;u&quot;body&quot;: u&quot;Sounds great! I&apos;ll get right on it once I feed my cat.&quot;&#125;)</div><div class="line">&gt;&gt;&gt; url = u&quot;https://api.github.com/repos/kennethreitz/requests/issues/comments/5804413&quot;</div><div class="line">&gt;&gt;&gt; r = requests.patch(url=url, data=body, auth=auth)</div><div class="line">&gt;&gt;&gt; r.status_code</div><div class="line">200</div></pre></td></tr></table></figure></p>
<p>非常好。现在，我们来折磨一下这个叫肯尼思的家伙，我决定要让他急得团团转，也不告诉他是我在捣蛋。 这意味着我想删除这条评论。GitHub允许我们使用完全名副其实的DELETE方法来删除评论。我们来清除该评论。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; r = requests.delete(url=url, auth=auth)</div><div class="line">&gt;&gt;&gt; r.status_code</div><div class="line">204</div><div class="line">&gt;&gt;&gt; r.headers[&apos;status&apos;]</div><div class="line">&apos;204 No Content&apos;</div></pre></td></tr></table></figure></p>
<p>很好。不见了。最后一件我想知道的事情是我已经使用了多少限额（ratelimit）。查查看，GitHub在响应头部发送这个信息， 因此不必下载整个网页，我将使用一个HEAD请求来获取响应头。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; r = requests.head(url=url, auth=auth)</div><div class="line">&gt;&gt;&gt; print r.headers</div><div class="line">...</div><div class="line">&apos;x-ratelimit-remaining&apos;: &apos;4995&apos;</div><div class="line">&apos;x-ratelimit-limit&apos;: &apos;5000&apos;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>很好。是时候写个Python程序以各种刺激的方式滥用GitHub的API，还可以使用4995次呢。</p>
<h2 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h2><ol>
<li><a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html#advanced" target="_blank" rel="external">高级用法-官方文档</a></li>
<li><a href="http://docs.python-requests.org/zh_CN/latest/api.html#sessionapi" target="_blank" rel="external">会话API文档</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	

	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单介绍"><span class="toc-number">1.</span> <span class="toc-text">简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送请求"><span class="toc-number">2.</span> <span class="toc-text">发送请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url参数传递"><span class="toc-number">3.</span> <span class="toc-text">url参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应内容"><span class="toc-number">4.</span> <span class="toc-text">响应内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二进制响应内容"><span class="toc-number">4.1.</span> <span class="toc-text">二进制响应内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON响应内容"><span class="toc-number">4.2.</span> <span class="toc-text">JSON响应内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原始响应内容"><span class="toc-number">4.3.</span> <span class="toc-text">原始响应内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定制请求头add-header"><span class="toc-number">5.</span> <span class="toc-text">定制请求头add header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更加复杂的POST请求"><span class="toc-number">6.</span> <span class="toc-text">更加复杂的POST请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应状态码"><span class="toc-number">7.</span> <span class="toc-text">响应状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应头-response-header"><span class="toc-number">8.</span> <span class="toc-text">响应头 response header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookies"><span class="toc-number">9.</span> <span class="toc-text">Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重定向与请求历史"><span class="toc-number">10.</span> <span class="toc-text">重定向与请求历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超时"><span class="toc-number">11.</span> <span class="toc-text">超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误与异常"><span class="toc-number">12.</span> <span class="toc-text">错误与异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-Link"><span class="toc-number">13.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-17T07:04:32.000Z"><a href="/hexo_blog/2016/01/17/Python-Basic-2016-01-17-python-basic-requests-基本用法/">2016-01-17</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/17/Python-Basic-2016-01-17-python-basic-requests-基本用法/">python-basic~requests的基本用法</a></h1>
  

    </header>

    <div class="entry">
      
          <!--
       
              <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单介绍"><span class="toc-number">1.</span> <span class="toc-text">简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发送请求"><span class="toc-number">2.</span> <span class="toc-text">发送请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url参数传递"><span class="toc-number">3.</span> <span class="toc-text">url参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应内容"><span class="toc-number">4.</span> <span class="toc-text">响应内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二进制响应内容"><span class="toc-number">4.1.</span> <span class="toc-text">二进制响应内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON响应内容"><span class="toc-number">4.2.</span> <span class="toc-text">JSON响应内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原始响应内容"><span class="toc-number">4.3.</span> <span class="toc-text">原始响应内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定制请求头add-header"><span class="toc-number">5.</span> <span class="toc-text">定制请求头add header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更加复杂的POST请求"><span class="toc-number">6.</span> <span class="toc-text">更加复杂的POST请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应状态码"><span class="toc-number">7.</span> <span class="toc-text">响应状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应头-response-header"><span class="toc-number">8.</span> <span class="toc-text">响应头 response header</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookies"><span class="toc-number">9.</span> <span class="toc-text">Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重定向与请求历史"><span class="toc-number">10.</span> <span class="toc-text">重定向与请求历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#超时"><span class="toc-number">11.</span> <span class="toc-text">超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误与异常"><span class="toc-number">12.</span> <span class="toc-text">错误与异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-Link"><span class="toc-number">13.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

                  

                  -->
        <h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>Python 标准库中的 <strong>urllib2</strong> 模块提供了你所需要的大多数 HTTP 功能，但是它的 API 太渣了。它是为另一个时代、另一个互联网所创建的。它需要巨量的工作，甚至包括各种方法覆盖，来完成最简单的任务。</p>
<p>Requests 使用的是 <strong>urllib3</strong>，因此继承了它的所有特性。</p>
<p>Requests 支持 HTTP 连接保持和连接池，支持使用 cookie 保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的 URL 和 POST 数据自动编码。现代、国际化、人性化。</p>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>使用Requests发送网络请求非常简单。</p>
<p>一开始要导入Requests模块:</p>
<pre><code>&gt;&gt;&gt; import requests
</code></pre><p>然后，尝试获取某个网页。本例子中，我们来获取Github的公共时间线</p>
<pre><code>&gt;&gt;&gt; r = requests.get(&apos;https://github.com/timeline.json&apos;)
</code></pre><p>现在，我们有一个名为 r 的 Response 对象。可以从这个对象中获取所有我们想要的信息。</p>
<p>Requests简便的API意味着所有HTTP请求类型都是显而易见的。例如，你可以这样发送一个HTTP POST请求:</p>
<pre><code>&gt;&gt;&gt; r = requests.post(&quot;http://httpbin.org/post&quot;)
</code></pre><p>漂亮，对吧？那么其他HTTP请求类型：<strong>PUT， DELETE， HEAD以及OPTIONS</strong>又是如何的呢？都是一样的简单:</p>
<pre><code>&gt;&gt;&gt; r = requests.put(&quot;http://httpbin.org/put&quot;)
&gt;&gt;&gt; r = requests.delete(&quot;http://httpbin.org/delete&quot;)
&gt;&gt;&gt; r = requests.head(&quot;http://httpbin.org/get&quot;)
&gt;&gt;&gt; r = requests.options(&quot;http://httpbin.org/get&quot;)
</code></pre><h3 id="url参数传递"><a href="#url参数传递" class="headerlink" title="url参数传递"></a>url参数传递</h3><p>你也许经常想为URL的查询字符串(query string)传递某种数据。如果你是手工构建URL，那么数据会以键/值 对的形式置于URL中，跟在一个问号的后面。例如， httpbin.org/get?key=val 。 </p>
<p>Requests允许你使用 params 关键字参数，以一个字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码:</p>
<pre><code>&gt;&gt;&gt; payload = {&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;}
&gt;&gt;&gt; r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)
</code></pre><p>通过打印输出该URL，你能看到URL已被正确编码:</p>
<pre><code>&gt;&gt;&gt; print(r.url)
http://httpbin.org/get?key2=value2&amp;key1=value1
</code></pre><p>注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。</p>
<h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><p>我们能读取服务器响应的内容。再次以Github时间线为例:</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; r = requests.get(&apos;https://github.com/timeline.json&apos;)
&gt;&gt;&gt; r.text
u&apos;[{&quot;repository&quot;:{&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/...
</code></pre><p>Requests会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码。</p>
<p>请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用 r.encoding 属性来改变它:</p>
<pre><code>&gt;&gt;&gt; r.encoding
&apos;utf-8&apos;
&gt;&gt;&gt; r.encoding = &apos;ISO-8859-1&apos;
</code></pre><p><strong>如果你改变了编码，每当你访问 r.text ，Request都将会使用 r.encoding 的新值</strong>。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。<br>比如 HTTP 和 XML 自身可以指定编码。这样的话，<strong>你应该使用 r.content 来找到编码，然后设置 r.encoding 为相应的编码。这样就能使用正确的编码解析 r.text 了。</strong></p>
<p>在你需要的情况下，Requests也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由Requests来为你处理编码。</p>
<h4 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h4><p>你也能以字节的方式访问请求响应体，对于非文本请求:</p>
<pre><code>&gt;&gt;&gt; r.content
b&apos;[{&quot;repository&quot;:{&quot;open_issues&quot;:0,&quot;url&quot;:&quot;https://github.com/...
</code></pre><p>Requests会自动为你解码 gzip 和 deflate 传输编码的响应数据。</p>
<p>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码:</p>
<pre><code>&gt;&gt;&gt; from PIL import Image
&gt;&gt;&gt; from StringIO import StringIO
&gt;&gt;&gt; i = Image.open(StringIO(r.content))
</code></pre><h4 id="JSON响应内容"><a href="#JSON响应内容" class="headerlink" title="JSON响应内容"></a>JSON响应内容</h4><p>Requests中也有一个内置的JSON解码器，助你处理JSON数据:</p>
<pre><code>&gt;&gt;&gt; import requests
&gt;&gt;&gt; r = requests.get(&apos;https://github.com/timeline.json&apos;)
&gt;&gt;&gt; r.json()
[{u&apos;repository&apos;: {u&apos;open_issues&apos;: 0, u&apos;url&apos;: &apos;https://github.com/...
</code></pre><p>如果JSON解码失败， r.json 就会抛出一个异常。例如，相应内容是 401 (Unauthorized) ，尝试访问 r.json 将会抛出 <code>ValueError: No JSON object could be decoded</code>异常。</p>
<h4 id="原始响应内容"><a href="#原始响应内容" class="headerlink" title="原始响应内容"></a>原始响应内容</h4><p>在罕见的情况下你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw 。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True 。具体的你可以这么做:</p>
<pre><code>&gt;&gt;&gt; r = requests.get(&apos;https://github.com/timeline.json&apos;, stream=True)
&gt;&gt;&gt; r.raw
&lt;requests.packages.urllib3.response.HTTPResponse object at 0x101194810&gt;
&gt;&gt;&gt; r.raw.read(10)
&apos;\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03&apos;
</code></pre><p>但一般情况下，你应该下面的模式将文本流保存到文件:</p>
<pre><code>with open(filename, &apos;wb&apos;) as fd:
    for chunk in r.iter_content(chunk_size):
        fd.write(chunk)
</code></pre><p>使用 <code>Response.iter_content</code> 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。</p>
<h3 id="定制请求头add-header"><a href="#定制请求头add-header" class="headerlink" title="定制请求头add header"></a>定制请求头add header</h3><p>如果你想为请求添加HTTP头部，只要简单地传递一个 dict 给 headers 参数就可以了。</p>
<p>例如，在前一个示例中我们没有指定content-type:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://api.github.com/some/endpoint'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">'content-type'</span>: <span class="string">'application/json'</span>&#125;</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.post(url, data=json.dumps(payload), headers=headers)</div></pre></td></tr></table></figure>
<h3 id="更加复杂的POST请求"><a href="#更加复杂的POST请求" class="headerlink" title="更加复杂的POST请求"></a>更加复杂的POST请求</h3><p>通常，你想要发送一些编码为表单形式的数据—非常像一个HTML表单。 要实现这个，<strong>只需简单地传递一个字典给 data 参数</strong>。你的数据字典 在发出请求时会自动编码为表单形式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</div><div class="line">&gt;&gt;&gt; r = requests.post(&quot;http://httpbin.org/post&quot;, data=payload)</div><div class="line">&gt;&gt;&gt; print r.text</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  &quot;form&quot;: &#123;</div><div class="line">    &quot;key2&quot;: &quot;value2&quot;,</div><div class="line">    &quot;key1&quot;: &quot;value1&quot;</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict ，那么数据会被直接发布出去。</p>
<p>例如，<em>Github API v3接受编码为JSON的POST/PATCH数据</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; import json</div><div class="line">&gt;&gt;&gt; url = &apos;https://api.github.com/some/endpoint&apos;</div><div class="line">&gt;&gt;&gt; payload = &#123;&apos;some&apos;: &apos;data&apos;&#125;</div><div class="line"></div><div class="line">&gt;&gt;&gt; r = requests.post(url, data=json.dumps(payload))</div></pre></td></tr></table></figure>
<h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>我们可以检测响应状态码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; r = requests.get(&apos;http://httpbin.org/get&apos;)</div><div class="line">&gt;&gt;&gt; r.status_code</div><div class="line">200</div></pre></td></tr></table></figure>
<p>为方便引用，Requests还附带了一个内置的状态码查询对象:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; r.status_code == requests.codes.ok</div><div class="line">True</div></pre></td></tr></table></figure>
<p>如果发送了一个失败请求(非200响应)，我们可以通过 Response.raise_for_status() 来抛出异常:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; bad_r = requests.get(&apos;http://httpbin.org/status/404&apos;)</div><div class="line">&gt;&gt;&gt; bad_r.status_code</div><div class="line">404</div><div class="line"></div><div class="line">&gt;&gt;&gt; bad_r.raise_for_status()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;requests/models.py&quot;, line 832, in raise_for_status</div><div class="line">    raise http_error</div><div class="line">requests.exceptions.HTTPError: 404 Client Error</div></pre></td></tr></table></figure>
<p>但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; r.raise_for_status()</div><div class="line">None</div></pre></td></tr></table></figure></p>
<h3 id="响应头-response-header"><a href="#响应头-response-header" class="headerlink" title="响应头 response header"></a>响应头 response header</h3><p>我们可以查看以一个Python字典形式展示的服务器响应头:</p>
<pre><code>&gt;&gt;&gt; r.headers
{
    &apos;content-encoding&apos;: &apos;gzip&apos;,
    &apos;transfer-encoding&apos;: &apos;chunked&apos;,
    &apos;connection&apos;: &apos;close&apos;,
    &apos;server&apos;: &apos;nginx/1.0.4&apos;,
    &apos;x-runtime&apos;: &apos;148ms&apos;,
    &apos;etag&apos;: &apos;&quot;e1ca502697e5c9317743dc078f67693f&quot;&apos;,
    &apos;content-type&apos;: &apos;application/json&apos;
}
</code></pre><p>但是这个字典比较特殊：它是仅为HTTP头部而生的。根据 RFC 2616 ， HTTP头部是大小写不敏感的。</p>
<p>因此，我们可以使用任意大写形式来访问这些响应头字段:</p>
<pre><code>&gt;&gt;&gt; r.headers[&apos;Content-Type&apos;]
&apos;application/json&apos;

&gt;&gt;&gt; r.headers.get(&apos;content-type&apos;)
&apos;application/json&apos;
</code></pre><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>如果某个响应中包含一些Cookie，你可以快速访问它们:</p>
<pre><code>&gt;&gt;&gt; url = &apos;http://example.com/some/cookie/setting/url&apos;
&gt;&gt;&gt; r = requests.get(url)

&gt;&gt;&gt; r.cookies[&apos;example_cookie_name&apos;]
&apos;example_cookie_value&apos;
</code></pre><p>要想发送你的cookies到服务器，可以使用 cookies 参数:</p>
<pre><code>&gt;&gt;&gt; url = &apos;http://httpbin.org/cookies&apos;
&gt;&gt;&gt; cookies = dict(cookies_are=&apos;working&apos;)

&gt;&gt;&gt; r = requests.get(url, cookies=cookies)
&gt;&gt;&gt; r.text
&apos;{&quot;cookies&quot;: {&quot;cookies_are&quot;: &quot;working&quot;}}&apos;
</code></pre><h3 id="重定向与请求历史"><a href="#重定向与请求历史" class="headerlink" title="重定向与请求历史"></a>重定向与请求历史</h3><p>默认情况下，除了 HEAD, Requests会自动处理所有重定向。</p>
<p>可以使用响应对象的 history 方法来追踪重定向。</p>
<p><code>Response.history</code> 是一个<code>:class:Response &lt;requests.Response&gt;</code> 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。</p>
<p>例如，Github将所有的HTTP请求重定向到HTTPS。:</p>
<pre><code>&gt;&gt;&gt; r = requests.get(&apos;http://github.com&apos;)
&gt;&gt;&gt; r.url
&apos;https://github.com/&apos;
&gt;&gt;&gt; r.status_code
200
&gt;&gt;&gt; r.history
[&lt;Response [301]&gt;]
</code></pre><p>如果你使用的是<em>GET, OPTIONS, POST, PUT, PATCH 或者 DELETE</em>,，那么你可以通过 allow_redirects 参数禁用重定向处理:</p>
<pre><code>&gt;&gt;&gt; r = requests.get(&apos;http://github.com&apos;, allow_redirects=False)
&gt;&gt;&gt; r.status_code
301
&gt;&gt;&gt; r.history
[]
</code></pre><p>如果你使用的是HEAD，你也可以启用重定向:</p>
<pre><code>&gt;&gt;&gt; r = requests.head(&apos;http://github.com&apos;, allow_redirects=True)
&gt;&gt;&gt; r.url
&apos;https://github.com/&apos;
&gt;&gt;&gt; r.history
[&lt;Response [301]&gt;]
</code></pre><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>你可以告诉requests在经过以 timeout 参数设定的秒数时间之后停止等待响应:</p>
<pre><code>&gt;&gt;&gt; requests.get(&apos;http://github.com&apos;, timeout=0.001)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
requests.exceptions.Timeout: HTTPConnectionPool(host=&apos;github.com&apos;, port=80): Request timed out. (timeout=0.001)
</code></pre><h3 id="错误与异常"><a href="#错误与异常" class="headerlink" title="错误与异常"></a>错误与异常</h3><p>遇到网络问题（如：DNS查询失败、拒绝连接等）时，Requests会抛出一个 <code>ConnectionError</code> 异常。</p>
<p>遇到罕见的无效HTTP响应时，Requests则会抛出一个 <code>HTTPError</code> 异常。</p>
<p>若请求超时，则抛出一个 Timeout 异常。</p>
<p>若请求超过了设定的最大重定向次数，则会抛出一个 <code>TooManyRedirects</code> 异常。</p>
<p>所有Requests显式抛出的异常都继承自 <code>requests.exceptions.RequestException</code> 。</p>
<h3 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h3><ol>
<li><a href="http://docs.python-requests.org/zh_CN/latest/index.html#" target="_blank" rel="external">requests:HTTP for humans-官方文档</a></li>
<li><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html#id8" target="_blank" rel="external">快速上手-官方文档</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	

	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-Spider-urllib-HTTP-urlib"><span class="toc-number">1.</span> <span class="toc-text">[Python][Spider][urllib]HTTP-urlib</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#POST和GET请求"><span class="toc-number">1.1.</span> <span class="toc-text">POST和GET请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#User-Agent"><span class="toc-number">1.2.</span> <span class="toc-text">User-Agent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-number">1.3.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-代理-ProxyHandler"><span class="toc-number">1.4.</span> <span class="toc-text">Proxy 代理 ProxyHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模拟浏览器-POST-GET-方式"><span class="toc-number">1.5.</span> <span class="toc-text">模拟浏览器 POST GET 方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#urllib库"><span class="toc-number">1.6.</span> <span class="toc-text">urllib库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#urllib-request-urlopen"><span class="toc-number">1.6.1.</span> <span class="toc-text">urllib.request.urlopen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#urllib-request-Request"><span class="toc-number">1.6.2.</span> <span class="toc-text">urllib.request.Request</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#urllib-request-urlopen-Request-示例代码"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">urllib.request.(urlopen,Request)示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见用法"><span class="toc-number">1.7.</span> <span class="toc-text">常见用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#直接将URL保存为本地文件："><span class="toc-number">1.7.1.</span> <span class="toc-text">直接将URL保存为本地文件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打印HTTP-header"><span class="toc-number">1.7.2.</span> <span class="toc-text">打印HTTP header</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-Link"><span class="toc-number">2.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-16T08:18:05.000Z"><a href="/hexo_blog/2016/01/16/Python-2016-01-16-python-lib-http-urlib-基础用法/">2016-01-16</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/16/Python-2016-01-16-python-lib-http-urlib-基础用法/">python-lib~http(urlib)基础用法</a></h1>
  

    </header>

    <div class="entry">
      
          <!--
       
              <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-Spider-urllib-HTTP-urlib"><span class="toc-number">1.</span> <span class="toc-text">[Python][Spider][urllib]HTTP-urlib</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#POST和GET请求"><span class="toc-number">1.1.</span> <span class="toc-text">POST和GET请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#User-Agent"><span class="toc-number">1.2.</span> <span class="toc-text">User-Agent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-number">1.3.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-代理-ProxyHandler"><span class="toc-number">1.4.</span> <span class="toc-text">Proxy 代理 ProxyHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模拟浏览器-POST-GET-方式"><span class="toc-number">1.5.</span> <span class="toc-text">模拟浏览器 POST GET 方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#urllib库"><span class="toc-number">1.6.</span> <span class="toc-text">urllib库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#urllib-request-urlopen"><span class="toc-number">1.6.1.</span> <span class="toc-text">urllib.request.urlopen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#urllib-request-Request"><span class="toc-number">1.6.2.</span> <span class="toc-text">urllib.request.Request</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#urllib-request-urlopen-Request-示例代码"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">urllib.request.(urlopen,Request)示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见用法"><span class="toc-number">1.7.</span> <span class="toc-text">常见用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#直接将URL保存为本地文件："><span class="toc-number">1.7.1.</span> <span class="toc-text">直接将URL保存为本地文件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打印HTTP-header"><span class="toc-number">1.7.2.</span> <span class="toc-text">打印HTTP header</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-Link"><span class="toc-number">2.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

                  

                  -->
        <h2 id="Python-Spider-urllib-HTTP-urlib"><a href="#Python-Spider-urllib-HTTP-urlib" class="headerlink" title="[Python][Spider][urllib]HTTP-urlib"></a>[Python][Spider][urllib]HTTP-urlib</h2><p>@(3.09 - Python)[python, urllib, spider]</p>
<p>注:  </p>
<blockquote>
<p>  python 3.x中urllib库和urilib2库合并成了urllib库。<br>    其中urllib2.urlopen()变成了<code>urllib.request.urlopen()</code><br>    urllib2.Request()变成了<code>urllib.request.Request()</code></p>
</blockquote>
<pre><code>from urllib import request
</code></pre><h3 id="POST和GET请求"><a href="#POST和GET请求" class="headerlink" title="POST和GET请求"></a>POST和GET请求</h3><p>HTTP定义了与服务器交互的不同方法，最基本的方法有4种，分别是<strong>GET，POST，PUT，DELETE</strong>。</p>
<p>一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。</p>
<p>其中，GET一般用于获取/查询资源信息，而POST一般用于更新资源信息，通常用于我们需要向服务器提交表单的情况。</p>
<p>比如说，我们在百度首页输入“宁哥的小站”，回车，然后地址栏会跳转到搜索结果的列表页。同时可以看到浏览器的地址栏会发生改变，类似于<code>http://www.baidu.com/s?wd=xxx</code>的形式。就是说，地址栏从百度首页<code>http://www.baidu.com/</code>跳转到了<code>http://www.baidu.com/s?wd=xxx</code><br>变化就在于，在最初的url后面会附加相关的字段，<strong>以？分割url和请求的数据</strong>，这些数据就是你要查询字段的编码。而这个过程，就是典型的GET请求的情况。</p>
<p>与之对应的POST请求则显得深藏不露，它在于你必须通过浏览器输入或提交一些服务器需要的数据，才能给你返回完整的界面，这点其实与GET请求情况有相通之处，但是<strong>这个过程浏览器的地址栏是不会发生跳转的</strong>。</p>
<p>POST请求提交的数据是如何传给服务器的呢？大家可以采用一些分析页面的手段来获取上传的数据。实际上，POST请求是将提交的数据放在HTTP包的包体中，这种方式无疑加强了数据的安全性，不像GET请求那样，用户可以通过跳转的url就可以查看出向服务器发送的数据。另外，POST请求除了提交数据外，还可以提交文件，这点也是GET请求做不到的。</p>
<h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><p>如何让网站们把我们的Python爬虫当成正规的浏览器来访. 因为如果不这么伪装自己, 有的网站就爬不回来了（有的网站专门拦截爬虫程序）. 如果看过理论方面的知识, 就知道我们是要在 GET 的时候将 User-Agent 添加到header里.</p>
<p>urllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的。</p>
<p><strong>Fiddler</strong></p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容是不允许的。那么我们可以保存我们登录的Cookie，然后再抓取其他页面就达到目的了。</p>
<p>Cookie是HTTP消息头中的一种属性，包括：<br>Cookie名字（Name）Cookie的值（Value），Cookie的过期时间（Expires/Max-Age），Cookie作用路径（Path），Cookie所在域名（Domain），使用Cookie进行安全连接（Secure）。 前两个参数是Cookie应用的必要条件，另外，还包括Cookie大小（Size，不同浏览器对Cookie个数及大小限制是有差异的）。</p>
<p>有了Cookie，我们就可以实现自动登陆网站，甚至能够解决一些验证码登陆的情况。</p>
<p>在Python中，提供了cookielib这个模块，能够将cookie保存到本地，也可以保存在内存中。在第一次用用户名密码登陆网站之后，我们只需要如下创建opener对象，就可以记录cookie：</p>
<p>这样，接下来我们如果继续访问该域名的网站，直接采用<code>opener.open(需要输入的url)</code>，就能实现用保存的Cookie直接打开。</p>
<p>本来处理 Cookies 是个麻烦的事情, 不过 Python 的 http.cookiejar 库给了我们很方便的解决方案, 只要在创建 opener 的时候将一个 HTTPCookieProcessor 放进去, Cookies 的事情就不用我们管了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> http.cookiejar</div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOpener</span><span class="params">(head)</span>:</span></div><div class="line">    <span class="comment"># deal with the Cookies</span></div><div class="line">    cj = http.cookiejar.CookieJar()</div><div class="line">    pro = urllib.request.HTTPCookieProcessor(cj)</div><div class="line">    opener = urllib.request.build_opener(pro)</div><div class="line">    header = []</div><div class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> head.items():</div><div class="line">        elem = (key, value)</div><div class="line">        header.append(elem)</div><div class="line">    opener.addheaders = header</div><div class="line">    <span class="keyword">return</span> opener</div></pre></td></tr></table></figure>
<p>getOpener 函数接收一个 head 参数, 这个参数是一个字典. 函数把字典转换成元组集合, 放进 opener. 这样我们建立的这个 opener 就有两大功能:</p>
<ul>
<li>自动处理使用 opener 过程中遇到的 Cookies</li>
<li>自动在发出的 GET 或者 POST 请求中加上自定义的 Header</li>
</ul>
<h3 id="Proxy-代理-ProxyHandler"><a href="#Proxy-代理-ProxyHandler" class="headerlink" title="Proxy 代理 ProxyHandler"></a>Proxy 代理 ProxyHandler</h3><p>示例代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">proxy_handler = urllib.request.ProxyHandler(&#123;&apos;http&apos;: &apos;http://www.example.com:3128/&apos;&#125;)</div><div class="line">proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()</div><div class="line">proxy_auth_handler.add_password(&apos;realm&apos;, &apos;host&apos;, &apos;username&apos;, &apos;password&apos;)</div><div class="line">opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)</div><div class="line">with opener.open(&apos;http://www.example.com/login.html&apos;) as f:</div><div class="line">    pass</div></pre></td></tr></table></figure></p>
<h3 id="模拟浏览器-POST-GET-方式"><a href="#模拟浏览器-POST-GET-方式" class="headerlink" title="模拟浏览器 POST GET 方式"></a>模拟浏览器 POST GET 方式</h3><p>POST方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import urllib.parse  </div><div class="line">import urllib.request  </div><div class="line"> </div><div class="line">url=&quot;http://liuxin-blog.appspot.com/messageboard/add&quot; </div><div class="line"></div><div class="line">values=&#123;&quot;content&quot;:&quot;命令行发出网页请求测试&quot;&#125;  </div><div class="line">data=urllib.parse.urlencode(values) </div><div class="line"></div><div class="line"># 创建请求对象  </div><div class="line">req=urllib.request.Request(url,data) </div><div class="line">#获得服务器返回的数据  </div><div class="line">response=urllib.request.urlopen(req) </div><div class="line">#处理数据  </div><div class="line">page=response.read()</div></pre></td></tr></table></figure>
<p>GET方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import urllib.parse  </div><div class="line">import urllib.request  </div><div class="line"></div><div class="line">url=&quot;http://www.google.cn/webhp&quot; </div><div class="line"></div><div class="line">values=&#123;&quot;rls&quot;:&quot;ig&quot;&#125;  </div><div class="line">data=urllib.parse.urlencode(values)  </div><div class="line"></div><div class="line">theurl=url+&quot;?&quot;+data </div><div class="line">#创建请求对象  </div><div class="line">req=urllib.request.Request(theurl) </div><div class="line">#获得服务器返回的数据  </div><div class="line">response=urllib.request.urlopen(req) </div><div class="line">#处理数据  </div><div class="line">page=response.read()</div></pre></td></tr></table></figure>
<h3 id="urllib库"><a href="#urllib库" class="headerlink" title="urllib库"></a>urllib库</h3><p>urllib.request module uses <strong>HTTP/1.1</strong> and includes <code>Connection:close</code> header in its HTTP requests.</p>
<p>对于Response对象</p>
<ul>
<li>geturl() — return the URL of the resource retrieved, commonly used to determine if a redirect was followed</li>
<li>info() — return the meta-information of the page, such as headers, in the form of an email.message_from_string() instance (see Quick Reference to HTTP Headers)</li>
<li>getcode() – return the HTTP status code of the response.</li>
</ul>
<p>geturl()的设置是为了辨别是否有服务器端的网址重定向,而info()[getheaders()]则包含了一系列的信息。</p>
<ol>
<li>info()</li>
<li>gerheaders()</li>
<li>f.status</li>
<li>f.reason</li>
</ol>
<h4 id="urllib-request-urlopen"><a href="#urllib-request-urlopen" class="headerlink" title="urllib.request.urlopen"></a>urllib.request.urlopen</h4><p>使用urllib.request库中的<code>urlopen(url)</code>函数来打开网页，函数参数url只能接受utf-8编码方式(因为Python脚本文件用utf-8编码)</p>
<p>urlopen一般接受三个参数，它的参数如下：<code>urlopen(url, data, timeout)</code></p>
<blockquote>
<p>第二三个参数是可以不传送的，data默认为空 None，timeout默认为 <code>socket._GLOBAL_DEFAULT_TIMEOUT</code></p>
<p>第一个参数URL是必须要传送的，url参数可以是一个字符串或者是一个Request请求。The URL url, which can be either a string or a Request object.<br>执行urlopen方法之后，返回一个<strong>response对象</strong>，返回信息便保存在这里面。</p>
<p>the HTTP request will be a <strong>POST</strong> instead of a <strong>GET</strong> when the data parameter is provided.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</div><div class="line">url = <span class="string">"https://api.douban.com/v2/book/2129650"</span></div><div class="line">Urequest = request.Request(url)</div><div class="line"><span class="keyword">with</span> request.urlopen(Urequest, timeout=<span class="number">5</span>) <span class="keyword">as</span> f:</div><div class="line">    print(f.read().decode(<span class="string">'utf-8'</span>))</div></pre></td></tr></table></figure>
<h4 id="urllib-request-Request"><a href="#urllib-request-Request" class="headerlink" title="urllib.request.Request"></a>urllib.request.Request</h4><p><code>urllib.request.Request((url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None))</code></p>
<ul>
<li><p><code>urllib.parse.urlencode()</code><br>data should be a buffer in the standard application/x-www-form-urlencoded format. The urllib.parse.urlencode() function takes a mapping or sequence of 2-tuples and returns an ASCII string in this format. <strong>It should be encoded to bytes before being used as the data parameter.</strong><br>如果要以POST发送一个请求，只需要把参数data以bytes形式传入。POST的表单数据用<code>urllib.parse.urlencode()</code>来格式化，该函数接收2-tuple数据，返回ASCII的字符串<br>POST data should be bytes or an iterable of bytes. It cannot be of type str。urlencode()返回的是ASCII的字符串，所以在引用的时候应该encode成Bytes类型的。</p>
</li>
<li><p><code>add_header()</code><br>给HTTP POST/GET添加请求报头，常用来伪装成浏览器<br><em>For example, Mozilla Firefox may identify itself as “Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11”, while urllib‘s default user agent string is “Python-urllib/2.6” (on Python 2.6).</em></p>
</li>
</ul>
<h5 id="urllib-request-urlopen-Request-示例代码"><a href="#urllib-request-urlopen-Request-示例代码" class="headerlink" title="urllib.request.(urlopen,Request)示例代码"></a>urllib.request.(urlopen,Request)示例代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</div><div class="line"></div><div class="line">print(<span class="string">'Login to weibo.cn...'</span>)</div><div class="line">email = input(<span class="string">'Email: '</span>)</div><div class="line">passwd = input(<span class="string">'Password: '</span>)</div><div class="line">login_data = parse.urlencode([</div><div class="line">    (<span class="string">'username'</span>, email),</div><div class="line">    (<span class="string">'password'</span>, passwd),</div><div class="line">    (<span class="string">'entry'</span>, <span class="string">'mweibo'</span>),</div><div class="line">    (<span class="string">'client_id'</span>, <span class="string">''</span>),</div><div class="line">    (<span class="string">'savestate'</span>, <span class="string">'1'</span>),</div><div class="line">    (<span class="string">'ec'</span>, <span class="string">''</span>),</div><div class="line">    (<span class="string">'pagerefer'</span>, <span class="string">'https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F'</span>)</div><div class="line">])</div><div class="line"></div><div class="line">req = request.Request(<span class="string">'https://passport.weibo.cn/sso/login'</span>)</div><div class="line">req.add_header(<span class="string">'Origin'</span>, <span class="string">'https://passport.weibo.cn'</span>)</div><div class="line">req.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25'</span>)</div><div class="line">req.add_header(<span class="string">'Referer'</span>, <span class="string">'https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F'</span>)</div><div class="line"></div><div class="line"><span class="keyword">with</span> request.urlopen(req, data=login_data.encode(<span class="string">'utf-8'</span>)) <span class="keyword">as</span> f:</div><div class="line">    print(<span class="string">'Status:'</span>, f.status, f.reason)</div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</div><div class="line">        print(<span class="string">'%s: %s'</span> % (k, v))</div><div class="line">    print(<span class="string">'Data:'</span>, f.read().decode(<span class="string">'utf-8'</span>))</div></pre></td></tr></table></figure>
<h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><h4 id="直接将URL保存为本地文件："><a href="#直接将URL保存为本地文件：" class="headerlink" title="直接将URL保存为本地文件："></a>直接将URL保存为本地文件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import urllib.request</div><div class="line">url=&quot;http://www.xxxx.com/1.jpg&quot;</div><div class="line">urllib.request.urlretrieve(url,r&quot;d:\temp\1.jpg&quot;)</div></pre></td></tr></table></figure>
<h4 id="打印HTTP-header"><a href="#打印HTTP-header" class="headerlink" title="打印HTTP header"></a>打印HTTP header</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</div><div class="line">url = <span class="string">"https://api.douban.com/v2/book/2129650"</span></div><div class="line">Urequest = request.Request(url)</div><div class="line"><span class="keyword">with</span> request.urlopen(Urequest, timeout=<span class="number">5</span>) <span class="keyword">as</span> f:</div><div class="line">    data = f.read()</div><div class="line">    <span class="keyword">print</span> (<span class="string">'Status:'</span>, f.status, f.reason)</div><div class="line">    <span class="comment"># print(f.read().decode('utf-8'))</span></div><div class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders() :</div><div class="line">        <span class="keyword">print</span> (<span class="string">"%s : %s"</span> % (k, v))</div><div class="line">    &gt; print(<span class="string">"Data: "</span>, data.decode(<span class="string">'utf-8'</span>))</div></pre></td></tr></table></figure>
<h2 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h2><ol>
<li><a href="https://docs.python.org/3.4/library/urllib.request.html?highlight=request#module-urllib.request" target="_blank" rel="external">iurllib.request — Extensible library for opening URLs</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432688314740a0aed473a39f47b09c8c7274c9ab6aee000" target="_blank" rel="external">urllib-廖雪峰</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	

	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本介绍-python3的字符串编码"><span class="toc-number">1.</span> <span class="toc-text">基本介绍-python3的字符串编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python3-中字符串编码的转换"><span class="toc-number">1.1.</span> <span class="toc-text">python3 中字符串编码的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python2-x-中的字符串编码转换"><span class="toc-number">1.2.</span> <span class="toc-text">python2.x 中的字符串编码转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isinstance-判断"><span class="toc-number">1.3.</span> <span class="toc-text">isinstance 判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取系统默认编码"><span class="toc-number">1.4.</span> <span class="toc-text">获取系统默认编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单字节的处理"><span class="toc-number">1.5.</span> <span class="toc-text">单字节的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#codecs-模块简介"><span class="toc-number">2.</span> <span class="toc-text">codecs 模块简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python2-读写文件"><span class="toc-number">2.1.</span> <span class="toc-text">python2 读写文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与编码相关的方法"><span class="toc-number">3.</span> <span class="toc-text">与编码相关的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-Link"><span class="toc-number">4.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-16T04:26:38.000Z"><a href="/hexo_blog/2016/01/16/Python-2016-01-16-python-basic-encode-decode字符编码/">2016-01-16</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/16/Python-2016-01-16-python-basic-encode-decode字符编码/">python-basic~encode_decode字符编码</a></h1>
  

    </header>

    <div class="entry">
      
          <!--
       
              <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本介绍-python3的字符串编码"><span class="toc-number">1.</span> <span class="toc-text">基本介绍-python3的字符串编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python3-中字符串编码的转换"><span class="toc-number">1.1.</span> <span class="toc-text">python3 中字符串编码的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python2-x-中的字符串编码转换"><span class="toc-number">1.2.</span> <span class="toc-text">python2.x 中的字符串编码转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isinstance-判断"><span class="toc-number">1.3.</span> <span class="toc-text">isinstance 判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取系统默认编码"><span class="toc-number">1.4.</span> <span class="toc-text">获取系统默认编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单字节的处理"><span class="toc-number">1.5.</span> <span class="toc-text">单字节的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#codecs-模块简介"><span class="toc-number">2.</span> <span class="toc-text">codecs 模块简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python2-读写文件"><span class="toc-number">2.1.</span> <span class="toc-text">python2 读写文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与编码相关的方法"><span class="toc-number">3.</span> <span class="toc-text">与编码相关的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reference-Link"><span class="toc-number">4.</span> <span class="toc-text">Reference Link</span></a></li></ol>
</div>

                  

                  -->
        <h3 id="基本介绍-python3的字符串编码"><a href="#基本介绍-python3的字符串编码" class="headerlink" title="基本介绍-python3的字符串编码"></a>基本介绍-python3的字符串编码</h3><p>在 Python 2 中，字符串分为 ASCII 码表示（‘some text’）和 Unicode 表示（u‘Unicode 字符串’），默认为 ASCII 码。</p>
<p>不过在 Python 3 中，默认就是万能的 Unicode 码了，所以字符串前面不用加字母 u 也可以写 Unicode 了，当然这不是重点，重点是不会有各种 ASCII 和 Unicode 转换和混用带来的错误了。</p>
<p>另外， <strong>Python 3 中增加了一种 bytes 对象</strong>（b‘\xb6\xfe\xbd\xf8\xd6\xc6\xca\xfd\xbe\xdd’），专门用来表示编码后的（二进制）数据，所以现在对字符串的编码就是从 str 到 bytes 的转换，反之亦然</p>
<ul>
<li>bytes(<em>pytho3新增对象</em>)<ul>
<li>在网络上传输</li>
<li>保存到磁盘</li>
<li>python: bytes类型以 b 前缀打头。</li>
</ul>
</li>
<li>Unicode<ul>
<li>计算机内存</li>
<li>python3 str: 以unicode保存</li>
<li>python2 str: str类型需以 u 前缀打头表示unicode类型</li>
</ul>
</li>
<li>utf-8,ascii,gbk,etc…<ul>
<li>保存到硬盘，传输</li>
<li>python3源代码: 默认假定.py源代码以utf-8保存，<code># -*- coding: utf-8 -*-</code>告诉python解释器，按照<code>utf-8</code>读取源代码 </li>
</ul>
</li>
</ul>
<h4 id="python3-中字符串编码的转换"><a href="#python3-中字符串编码的转换" class="headerlink" title="python3 中字符串编码的转换"></a>python3 中字符串编码的转换</h4><p>在Python3中，每個字串都是Unicode，不使用內部编码表現，而使用str实例作為代表。如果想将字串转为指定的编码，可以使用<code>encode()</code>方法取得一個bytes实例，如果有個bytes实例，也可以使用<code>decode()</code>方法指定编码取得str实例：</p>
<pre><code>&gt;&gt;&gt; &apos;元&apos;.encode(&apos;big5&apos;)
b&apos;\xa4\xb8&apos;
&gt;&gt;&gt; &apos;元&apos;.encode(&apos;utf-8&apos;)
b&apos;\xe5\x85\x83&apos;
&gt;&gt;&gt; &apos;元&apos;.encode(&apos;big5&apos;).decode(&apos;big5&apos;)
&apos;元&apos;
</code></pre><p><img src="/hexo_blog/images/python/string-encoding-python3.jpg" alt=""></p>
<p><em>python3的<code>print</code>函数只支持<code>unicode</code>的str，貌似没有对bytes的解码功能，所以对对不能解码的bytes不能正确输出。</em></p>
<h4 id="python2-x-中的字符串编码转换"><a href="#python2-x-中的字符串编码转换" class="headerlink" title="python2.x 中的字符串编码转换"></a>python2.x 中的字符串编码转换</h4><p><strong>在编码转换时通常需要以unicode作为中间编码</strong><br>先将其他编码的字符串解码(decode)成unicode，再从unicode编码(encode)成另一种编码</p>
<ol>
<li>decode的作用是将其他编码的字符串转换成unicode编码</li>
<li>encode的作用是将unicode编码转换成其他编码的字符串</li>
</ol>
<p>比如从文件读入utf-8编码格式的字符串s，</p>
<pre><code>s.decode(&quot;utf-8&quot;, &quot;ignore&quot;).encode(&quot;gbk&quot;, &quot;ignore&quot;) # 先由utf-8转为unicode，再由unicode转为gbk，ignore表示忽略非法字符

&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)
&apos;ABC&apos;
&gt;&gt;&gt; b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;.decode(&apos;utf-8&apos;)
&apos;中文&apos;
</code></pre><h4 id="isinstance-判断"><a href="#isinstance-判断" class="headerlink" title="isinstance 判断"></a>isinstance 判断</h4><pre><code>def TestisStrOrUnicdeOrString():
  bs = b&apos;Hello&apos;
  ustr = &apos;abc&apos;
  print (isinstance(bs, str))  #False
  print (isinstance(bs,bytes)) #True
  print (isinstance(ustr,str)) #True
  print (isinstance(ustr, bytes)) #False
  print (isinstance(bs,(bytes,str))) #True
</code></pre><h4 id="获取系统默认编码"><a href="#获取系统默认编码" class="headerlink" title="获取系统默认编码"></a>获取系统默认编码</h4><p>Python3中默认是UTF-8，我们通过以下代码：</p>
<pre><code>import sys
sys.getdefaultencoding()
# &apos;uft-8&apos;
</code></pre><h4 id="单字节的处理"><a href="#单字节的处理" class="headerlink" title="单字节的处理"></a>单字节的处理</h4><ol>
<li><p>ord():<code>ord(&#39;A&#39;) == 65</code></p>
</li>
<li><p>chr():<code>chr(65) == &#39;A&#39;</code></p>
</li>
</ol>
<h3 id="codecs-模块简介"><a href="#codecs-模块简介" class="headerlink" title="codecs 模块简介"></a>codecs 模块简介</h3><p>codecs是encoders和decoders的缩写。</p>
<p>codecs模块为我们解决的字符编码的处理提供了lookup方法，它接受一个字符编码名称的参数，并返回指定字符编码对应的codecs.CodecInfo 对象，该对象包含了 encoder、decoder、StreamReader和StreamWriter的函数对象和类对象的引用。为了简化对lookup方法的调用， codecs还提供了getencoder(encoding)、getdecoder(encoding)、getreader(encoding)和 getwriter(encoding)方法；进一步，简化对特定字符编码的StreamReader、StreamWriter和 StreamReaderWriter的访问，codecs更直接地提供了open方法，通过encoding参数传递字符编码名称，即可获得对 encoder和decoder的双向服务。</p>
<p>这个模块的强大之处在于它提供了流的方式来处理字符串编码，当处理的数据很多时，这种方式很有用。<br>你可以使用IncrementalEncoder和IncrementalDecoder，但是强烈建议使用StreamReader和StreamWriter，因为使用它们会大大简化你的代码。</p>
<p>例如，有一个test.txt的文件，它的编码为gbk，现在我需要将它的编码转换为utf8，可以编写如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#coding:utf8</span></div><div class="line"><span class="keyword">import</span> codecs</div><div class="line"><span class="comment"># 打开文件 如果此处用codecs.open()方法打开文件，就不用创建reader和writer </span></div><div class="line">fin = open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) </div><div class="line">fout = open(<span class="string">'utf8.txt'</span>, <span class="string">'w'</span>) </div><div class="line"><span class="comment"># 获取 StreamReader </span></div><div class="line">reader = codecs.getreader(<span class="string">'gbk'</span>)(fin) </div><div class="line"><span class="comment"># 获取 StreamWriter </span></div><div class="line">writer = codecs.getwriter(<span class="string">'utf8'</span>)(fout) </div><div class="line">din = reader.read(<span class="number">10</span>) </div><div class="line"><span class="keyword">while</span> din: </div><div class="line">    writer.write(din) </div><div class="line">    din = reader.read(<span class="number">10</span>)</div></pre></td></tr></table></figure>
<p><em>用codecs提供的open方法来指定打开的文件的语言编码，它会在读取的时候自动转换为内部unicode</em></p>
<h4 id="python2-读写文件"><a href="#python2-读写文件" class="headerlink" title="python2 读写文件"></a>python2 读写文件</h4><p>内置的open()方法打开文件时，<br>read()读取的是str，读取后需要使用正确的编码格式进行decode()。<br>write()写入时，如果参数是unicode，则需要使用你希望写入的编码进行encode()，</p>
<p>如果是其他编码格式的str，则需要先用该str的编码进行decode()，转成unicode后再使用写入的编码进行encode()。<br>如果直接将unicode作为参数传入write()方法，Python将先使用源代码文件声明的字符编码进行编码然后写入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># coding: UTF-8</span></div><div class="line"> </div><div class="line">f = open(<span class="string">'test.txt'</span>)</div><div class="line">s = f.read()</div><div class="line">f.close()</div><div class="line"><span class="keyword">print</span> type(s) <span class="comment"># &lt;type 'str'&gt;</span></div><div class="line"><span class="comment"># 已知是GBK编码，解码成unicode</span></div><div class="line">u = s.decode(<span class="string">'GBK'</span>)</div><div class="line"> </div><div class="line">f = open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>)</div><div class="line"><span class="comment"># 编码成UTF-8编码的str</span></div><div class="line">s = u.encode(<span class="string">'UTF-8'</span>)</div><div class="line">f.write(s)</div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>模块codecs提供了一个open()方法，可以指定一个编码打开文件，使用这个方法打开的文件读取返回的将是unicode。<br>写入时，<br>如果参数是unicode，则使用open()时指定的编码进行编码后写入；<br>如果是str，则先根据源代码文件声明的字符编码，解码成unicode后再进行前述操作。<br>相对内置的open()来说，这个方法比较不容易在编码上出现问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># coding: GBK</span></div><div class="line"><span class="keyword">import</span> codecs</div><div class="line"> </div><div class="line">f = codecs.open(<span class="string">'test.txt'</span>, encoding=<span class="string">'UTF-8'</span>)</div><div class="line">u = f.read()</div><div class="line">f.close()</div><div class="line"><span class="keyword">print</span> type(u) <span class="comment"># &lt;type 'unicode'&gt;</span></div><div class="line"> </div><div class="line"><span class="comment"># codecs 以utf-8编码打开文件，转换成unicode编码</span></div><div class="line">f = codecs.open(<span class="string">'test.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'UTF-8'</span>)</div><div class="line"><span class="comment"># 写入unicode</span></div><div class="line">f.write(u)</div><div class="line"> </div><div class="line"><span class="comment"># 写入str，自动进行解码编码操作</span></div><div class="line"><span class="comment"># GBK编码的str</span></div><div class="line">s = <span class="string">'汉'</span></div><div class="line"><span class="keyword">print</span> repr(s) <span class="comment"># '\xba\xba'</span></div><div class="line"><span class="comment"># 这里会先将GBK编码的str解码为unicode再编码为UTF-8写入</span></div><div class="line">f.write(s) </div><div class="line">f.close()</div></pre></td></tr></table></figure>
<h3 id="与编码相关的方法"><a href="#与编码相关的方法" class="headerlink" title="与编码相关的方法"></a>与编码相关的方法</h3><p>sys/locale模块中提供了一些获取当前环境下的默认编码的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># coding:gbk</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> locale</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span><span class="params">(f)</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'%s.%s(): %s'</span> % (f.__module__, f.__name__, f())</div><div class="line"> </div><div class="line"><span class="comment"># 返回当前系统所使用的默认字符编码</span></div><div class="line">p(sys.getdefaultencoding)</div><div class="line"> </div><div class="line"><span class="comment"># 返回用于转换Unicode文件名至系统文件名所使用的编码</span></div><div class="line">p(sys.getfilesystemencoding)</div><div class="line"> </div><div class="line"><span class="comment"># 获取默认的区域设置并返回元祖(语言, 编码)</span></div><div class="line">p(locale.getdefaultlocale)</div><div class="line"> </div><div class="line"><span class="comment"># 返回用户设定的文本数据编码</span></div><div class="line"><span class="comment"># 文档提到this function only returns a guess</span></div><div class="line">p(locale.getpreferredencoding)</div><div class="line"> </div><div class="line"><span class="comment"># \xba\xba是'汉'的GBK编码</span></div><div class="line"><span class="comment"># mbcs是不推荐使用的编码，这里仅作测试表明为什么不应该用</span></div><div class="line"><span class="keyword">print</span> <span class="string">r"'\xba\xba'.decode('mbcs'):"</span>, repr(<span class="string">'\xba\xba'</span>.decode(<span class="string">'mbcs'</span>))</div><div class="line"> </div><div class="line"><span class="comment">#在笔者的Windows上的结果(区域设置为中文(简体, 中国))</span></div><div class="line"><span class="comment">#sys.getdefaultencoding(): gbk</span></div><div class="line"><span class="comment">#sys.getfilesystemencoding(): mbcs</span></div><div class="line"><span class="comment">#locale.getdefaultlocale(): ('zh_CN', 'cp936')</span></div><div class="line"><span class="comment">#locale.getpreferredencoding(): cp936</span></div><div class="line"><span class="comment">#'\xba\xba'.decode('mbcs'): u'\u6c49'</span></div></pre></td></tr></table></figure>
<h3 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h3><ol>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="external">字符串和编码-廖雪峰</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	

	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#python调用cmd命令"><span class="toc-number">1.</span> <span class="toc-text">python调用cmd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变参数-args与-kwargs的应用"><span class="toc-number">2.</span> <span class="toc-text">可变参数*args与**kwargs的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeautifulSoup通过find-all-方法实现注释的提取"><span class="toc-number">3.</span> <span class="toc-text">BeautifulSoup通过find_all()方法实现注释的提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python中版本号的判断"><span class="toc-number">4.</span> <span class="toc-text">python中版本号的判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python的依赖安装requirements-txt"><span class="toc-number">5.</span> <span class="toc-text">Python的依赖安装requirements.txt</span></a></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-15T16:54:11.000Z"><a href="/hexo_blog/2016/01/16/Python-2016-01-16-python-common-issue/">2016-01-16</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/16/Python-2016-01-16-python-common-issue/">python~common-issue常见问题</a></h1>
  

    </header>

    <div class="entry">
      
          <!--
       
              <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#python调用cmd命令"><span class="toc-number">1.</span> <span class="toc-text">python调用cmd命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变参数-args与-kwargs的应用"><span class="toc-number">2.</span> <span class="toc-text">可变参数*args与**kwargs的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeautifulSoup通过find-all-方法实现注释的提取"><span class="toc-number">3.</span> <span class="toc-text">BeautifulSoup通过find_all()方法实现注释的提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python中版本号的判断"><span class="toc-number">4.</span> <span class="toc-text">python中版本号的判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python的依赖安装requirements-txt"><span class="toc-number">5.</span> <span class="toc-text">Python的依赖安装requirements.txt</span></a></li></ol>
</div>

                  

                  -->
        <h3 id="python调用cmd命令"><a href="#python调用cmd命令" class="headerlink" title="python调用cmd命令"></a>python调用cmd命令</h3><ul>
<li><a href="http://www.lining0806.com/python%E8%B0%83%E7%94%A8cmd%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">fireling的数据空间|宁哥的小站 » Python调用cmd命令</a></li>
</ul>
<p>Python调用cmd命令，比较常见的有两种方法：</p>
<p>第一种可以使用os.system(“cmd”)，如</p>
<pre><code>import os
os.system(&quot;ipconfig /all&quot;)
</code></pre><p>第二种可以使用Popen模块产生新的process，如</p>
<pre><code>import subprocess
proc = subprocess.Popen(&quot;ipconfig /all&quot;, shell = True)
proc.wait() # 等待子进程结束
</code></pre><p>但是我们要注意的是，Popen使用时shell参数的设置。一般情况下，需要加上<code>shell = True</code>。</p>
<h3 id="可变参数-args与-kwargs的应用"><a href="#可变参数-args与-kwargs的应用" class="headerlink" title="可变参数*args与**kwargs的应用"></a>可变参数<code>*args</code>与<code>**kwargs</code>的应用</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">"list has &#123;args_len&#125; params, and dict has &#123;dict_len&#125; params"</span>.format(args_len=len(args), dict_len=len(kwargs)))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,a=<span class="number">4</span>,b=<span class="number">5</span>)</div><div class="line">    <span class="comment"># 下面这种方式 list 有 2 个参数，dict有0个参数</span></div><div class="line">    <span class="comment"># f([1,2,3],&#123;"fa":"nohg"&#125;)</span></div><div class="line"></div><div class="line"><span class="comment"># output :</span></div><div class="line"><span class="comment"># list has 3 params, and dict has 2 params</span></div></pre></td></tr></table></figure>
<h3 id="BeautifulSoup通过find-all-方法实现注释的提取"><a href="#BeautifulSoup通过find-all-方法实现注释的提取" class="headerlink" title="BeautifulSoup通过find_all()方法实现注释的提取"></a>BeautifulSoup通过find_all()方法实现注释的提取</h3><ol>
<li><a href="http://stackoverflow.com/questions/6062210/how-to-find-the-comment-tag-with-beautifulsoup" target="_blank" rel="external">ref-to stackoverflow</a></li>
<li><p><a href="https://my.oschina.net/ioslighter/blog/423166" target="_blank" rel="external">用Python提取HTML源码中的注释与去掉注释</a></p>
</li>
<li><p><a href="https://www.crummy.com/software/BeautifulSoup/bs3/documentation.html#Removing%20elements" target="_blank" rel="external">Removing element - elementref.extract()</a></p>
</li>
</ol>
<blockquote>
<p>Q : How to find the comment tag <!--…--> with BeautifulSoup?</p>
</blockquote>
<p>You can find all the comments in a document with via the <code>find_all</code> method. </p>
<p>See this example showing how to do exactly what you’re trying to do Removing elements:</p>
<p>In brief, you want this:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">comments = soup.find_all(text=<span class="keyword">lambda</span> text:isinstance(text, Comment))</div></pre></td></tr></table></figure>
<p>Edit: If you’re trying to search within the columns, you can try:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup, Comment</div><div class="line"><span class="keyword">import</span> re</div><div class="line">comments = soup.find_all(text=<span class="keyword">lambda</span> text:isinstance(text, Comment))</div><div class="line"><span class="keyword">for</span> comment <span class="keyword">in</span> comments:</div><div class="line">  e = re.match(<span class="string">r'&lt;i&gt;([^&lt;]*)&lt;/i&gt;'</span>, comment.string).group(<span class="number">1</span>)</div><div class="line">    print(e)</div></pre></td></tr></table></figure>
<h3 id="python中版本号的判断"><a href="#python中版本号的判断" class="headerlink" title="python中版本号的判断"></a>python中版本号的判断</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import sys</div><div class="line">print(sys.version_info)</div></pre></td></tr></table></figure>
<h3 id="Python的依赖安装requirements-txt"><a href="#Python的依赖安装requirements-txt" class="headerlink" title="Python的依赖安装requirements.txt"></a>Python的依赖安装requirements.txt</h3>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	

	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#pyenv管理不同的版本"><span class="toc-number">1.</span> <span class="toc-text">pyenv管理不同的版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装pyenv"><span class="toc-number">1.1.</span> <span class="toc-text">安装pyenv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装Python"><span class="toc-number">1.2.</span> <span class="toc-text">安装Python</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装Python的依赖包"><span class="toc-number">1.3.</span> <span class="toc-text">安装Python的依赖包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装本地下载好的Python安装包"><span class="toc-number">1.4.</span> <span class="toc-text">安装本地下载好的Python安装包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看当前已经安装的python版本"><span class="toc-number">1.5.</span> <span class="toc-text">查看当前已经安装的python版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置全局的python版本"><span class="toc-number">1.6.</span> <span class="toc-text">设置全局的python版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确认python版本"><span class="toc-number">1.7.</span> <span class="toc-text">确认python版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考链接"><span class="toc-number">1.8.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pip包管理命令"><span class="toc-number">2.</span> <span class="toc-text">pip包管理命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows下pip的安装"><span class="toc-number">3.</span> <span class="toc-text">windows下pip的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">4.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python-pip-Pillow-安装"><span class="toc-number">4.1.</span> <span class="toc-text">[python][pip][Pillow]安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows下lxml的安装"><span class="toc-number">5.</span> <span class="toc-text">windows下lxml的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#matplotlib安装"><span class="toc-number">6.</span> <span class="toc-text">matplotlib安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Building-on-Linux"><span class="toc-number">6.1.</span> <span class="toc-text">Building on Linux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#backend"><span class="toc-number">6.2.</span> <span class="toc-text">backend</span></a></li></ol></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-14T16:57:52.000Z"><a href="/hexo_blog/2016/01/15/Python-2016-01-15-python-IDE-python开发环境配置/">2016-01-15</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/15/Python-2016-01-15-python-IDE-python开发环境配置/">python-IDE~python开发环境配置</a></h1>
  

    </header>

    <div class="entry">
      
          <!--
       
              <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#pyenv管理不同的版本"><span class="toc-number">1.</span> <span class="toc-text">pyenv管理不同的版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装pyenv"><span class="toc-number">1.1.</span> <span class="toc-text">安装pyenv</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装Python"><span class="toc-number">1.2.</span> <span class="toc-text">安装Python</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装Python的依赖包"><span class="toc-number">1.3.</span> <span class="toc-text">安装Python的依赖包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#安装本地下载好的Python安装包"><span class="toc-number">1.4.</span> <span class="toc-text">安装本地下载好的Python安装包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看当前已经安装的python版本"><span class="toc-number">1.5.</span> <span class="toc-text">查看当前已经安装的python版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置全局的python版本"><span class="toc-number">1.6.</span> <span class="toc-text">设置全局的python版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确认python版本"><span class="toc-number">1.7.</span> <span class="toc-text">确认python版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考链接"><span class="toc-number">1.8.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pip包管理命令"><span class="toc-number">2.</span> <span class="toc-text">pip包管理命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows下pip的安装"><span class="toc-number">3.</span> <span class="toc-text">windows下pip的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他"><span class="toc-number">4.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python-pip-Pillow-安装"><span class="toc-number">4.1.</span> <span class="toc-text">[python][pip][Pillow]安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#windows下lxml的安装"><span class="toc-number">5.</span> <span class="toc-text">windows下lxml的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#matplotlib安装"><span class="toc-number">6.</span> <span class="toc-text">matplotlib安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Building-on-Linux"><span class="toc-number">6.1.</span> <span class="toc-text">Building on Linux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#backend"><span class="toc-number">6.2.</span> <span class="toc-text">backend</span></a></li></ol></li></ol>
</div>

                  

                  -->
        <h3 id="pyenv管理不同的版本"><a href="#pyenv管理不同的版本" class="headerlink" title="pyenv管理不同的版本"></a>pyenv管理不同的版本</h3><p>经常遇到这样的情况：</p>
<ul>
<li>系统自带的Python是2.6，自己需要Python 2.7中的某些特性；</li>
<li>系统自带的Python是2.x，自己需要Python 3.x；<br>此时需要在系统中安装多个Python，但又不能影响系统自带的Python，即需要实现Python的多版本共存。pyenv就是这样一个Python版本管理器。</li>
</ul>
<h4 id="安装pyenv"><a href="#安装pyenv" class="headerlink" title="安装pyenv"></a>安装pyenv</h4><pre><code>$ git clone git://github.com/yyuu/pyenv.git ~/.pyenv
$ echo &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bashrc
$ echo &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrc
$ echo &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bashrc
$ exec $SHELL -l
</code></pre><h4 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h4><p>查看可安装的版本</p>
<pre><code>$ pyenv install --list
</code></pre><p>该命令会列出可以用pyenv安装的Python版本，仅列举几个:</p>
<pre><code>2.7.8   # Python 2最新版本
3.4.1   # Python 3最新版本
anaconda-2.0.1  # 支持Python 2.6和2.7
anaconda3-2.0.1 # 支持Python 3.3和3.4
</code></pre><p>其中形如 x.x.x 这样的只有版本号的为Python官方版本，其他的形如 xxxxx-x.x.x 这种既有名称又有版本后的属于“衍生版”或发行版。</p>
<h4 id="安装Python的依赖包"><a href="#安装Python的依赖包" class="headerlink" title="安装Python的依赖包"></a>安装Python的依赖包</h4><p>如果我们确定要安装python3.4.3的话，接下来我们就可以安装python了，但是再安装之前，我们必须要安装python所需要的依赖包，这个必须要安装，安装会失败的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">sudo apt-get install libc6-dev gcc</div><div class="line">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm</div></pre></td></tr></table></figure>
<p>上面的依赖包搞定之后，我们就可以安装python了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">pyenv install 3.4.3 -v</div></pre></td></tr></table></figure>
<p>该命令会从github上下载python的源代码，并解压到/tmp目录下，然后在/tmp中执行编译工作。若依赖包没有安装，则会出现编译错误，需要在安装依赖包滞后重新执行该命令。</p>
<p>安装完成之后，需要使用如下命令对数据库进行更新：</p>
<pre><code>pyenv rehash
</code></pre><h4 id="安装本地下载好的Python安装包"><a href="#安装本地下载好的Python安装包" class="headerlink" title="安装本地下载好的Python安装包"></a>安装本地下载好的Python安装包</h4><p>到官网把安装包单独下载好，比如我讲下载好的包 <code>Python-3.5.1.tar.xz</code></p>
<p>放到 <code>~/Downloads</code> 目录下，然后指定build缓存目录后，再运行install命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line"><span class="built_in">export</span> PYTHON_BUILD_CACHE_PATH=~/Downloads</div><div class="line">pyenv install 3.5.1</div><div class="line">pyenv <span class="built_in">rehash</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>注，另一种说法<br>如果网络不太好，用 pyenv 下载会比较慢，可以先执行该命令，<br>然后到 ~/.pyenv/cache 目录下查看要下载的文件的文件名，<br>然后自己到官方网站下载，并将文件放在 ~/.pyenv/cache 目录下。<br>pyenv 会检查文件的完整性，若确认无误，则不会再重新下载。</p>
</blockquote>
<h4 id="查看当前已经安装的python版本"><a href="#查看当前已经安装的python版本" class="headerlink" title="查看当前已经安装的python版本"></a>查看当前已经安装的python版本</h4><pre><code>$ pyenv versions
* system (set by /home/seisman/.pyenv/version)
3.4.3
</code></pre><p>其中星号代表是当前系统正在使用的python版本是系统自带的。</p>
<h4 id="设置全局的python版本"><a href="#设置全局的python版本" class="headerlink" title="设置全局的python版本"></a>设置全局的python版本</h4><pre><code>$ pyenv global 3.4.3
$ pyenv versions
system
* 3.4.3 (set by /home/seisman/.pyenv/version)
</code></pre><p>从上面，我们可以看出来当前的python版本已经变为了3.4.3。也可以使用pyenv local或pyenv shell临时改变python的版本。</p>
<h4 id="确认python版本"><a href="#确认python版本" class="headerlink" title="确认python版本"></a>确认python版本</h4><pre><code>$ python
Python 3.4.3 (default, Apr  1 2015, 19:10:43) 
[GCC 4.8.2] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
</code></pre><p>注意事项：</p>
<p>使用python<br>输入 python 即可使用新版本的python；<br>系统自带的脚本会以 /usr/bin/python 的方式直接调用老版本的python，因而不会对系统脚本产生影响；<br>使用 pip 安装第三方模块时会安装到 ~/.pyenv/versions/3.4.1 下，不会和系统模块发生冲突。<br>使用 pip 安装模块后，可能需要执行 <code>pyenv rehash</code> 更新数据库；</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="http://seisman.info/python-pyenv.html" target="_blank" rel="external">python多版本共存之pyenv</a></li>
</ol>
<h3 id="pip包管理命令"><a href="#pip包管理命令" class="headerlink" title="pip包管理命令"></a>pip包管理命令</h3><ol>
<li>install                     Install packages.  </li>
<li>uninstall                   Uninstall packages.  </li>
<li>freeze                      Output installed packages in requirements format.  </li>
<li>list                        List installed packages.  </li>
<li>show                        Show information about installed packages.  </li>
<li>search                      Search PyPI for packages.  </li>
<li>wheel                       Build wheels from your requirements.  </li>
<li>zip                         DEPRECATED. Zip individual packages.  </li>
<li>unzip                       DEPRECATED. Unzip individual packages.  </li>
<li>help                       Show help for commands.  </li>
</ol>
<h3 id="windows下pip的安装"><a href="#windows下pip的安装" class="headerlink" title="windows下pip的安装"></a>windows下pip的安装</h3><p>pip也可以在Windows下安装，使用也和linux下一样简单。</p>
<p>先从下面的地址下载pip源码<code>source</code>：</p>
<p><a href="http://pypi.python.org/pypi/pip/" target="_blank" rel="external">http://pypi.python.org/pypi/pip/</a></p>
<p>下载下来后解压，打开命令行：</p>
<ol>
<li><p>利用cd命令进入pip源码目录，假设源码放在F:\python\pip-6.0.8，则执行下面的命令：</p>
<pre><code>cd f:\python\pip-6.0.8  
</code></pre></li>
<li><p>在安装前必须确保python的路径已经加入到系统的PATH环境变量中，如果没有，可以用下面的命令来指定：</p>
<pre><code>set PATH=%PATH%;&quot;your python install path&quot;  
</code></pre></li>
<li><p>再运行下面的命令进行安装：</p>
<pre><code>python setup.py install  
</code></pre><p>等待片刻，一堆打印过后即可安装成功。</p>
</li>
</ol>
<p>要安装python包也很简单，只要运行命令：</p>
<pre><code>python -m pip install &lt;package name&gt;  
</code></pre><p>如要安装mysql的python支持包，可执行下面的命令：</p>
<pre><code>python -m pip install mysql  
</code></pre><p>完整的pip命令如下：</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="python-pip-Pillow-安装"><a href="#python-pip-Pillow-安装" class="headerlink" title="[python][pip][Pillow]安装"></a>[python][pip][Pillow]安装</h4><p>环境：python 3.4.3, Ubuntu 14.04</p>
<p>直接运行命令</p>
<pre><code>pip install Pillow
</code></pre><p>如果出现以下错误：</p>
<pre><code>ValueError: --enable-jpeg requested but jpeg not found, aborting.
</code></pre><p>说明没有安装Jpeg的底包</p>
<p>安装:</p>
<pre><code>sudo apt-get install libjpeg-dev
</code></pre><p>然后继续安装即可</p>
<h3 id="windows下lxml的安装"><a href="#windows下lxml的安装" class="headerlink" title="windows下lxml的安装"></a>windows下lxml的安装</h3><p>背景：在cmd命令下直接使用<code>pip3 install lxml</code>会出现缺少VC++依赖库的提示。</p>
<p>可直接下载二进制包安装</p>
<p>作者：深海鱼<br>链接：[<a href="http://www.zhihu.com/question/26857761/answer/69754633" target="_blank" rel="external">http://www.zhihu.com/question/26857761/answer/69754633</a>]<br>来源：知乎</p>
<ol>
<li>安装wheel，命令行运行：<code>pip3 install wheel</code></li>
<li><p>在这里下载对应的.whl文件，注意别改文件名！[<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml" target="_blank" rel="external">http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml</a>]<br>Ctrl+F，输入lxml，找到</p>
<pre><code>Lxml, a binding for the libxml2 and libxslt libraries.
lxml-3.4.4-cp27-none-win32.whl
lxml-3.4.4-cp27-none-win_amd64.whl
lxml-3.4.4-cp34-none-win32.whl
lxml-3.4.4-cp34-none-win_amd64.whl
lxml-3.4.4-cp35-none-win32.whl
lxml-3.4.4-cp35-none-win_amd64.whl
lxml-3.5.0-cp27-none-win32.whl
lxml-3.5.0-cp27-none-win_amd64.whl
lxml-3.5.0-cp34-none-win32.whl
lxml-3.5.0-cp34-none-win_amd64.whl
lxml-3.5.0-cp35-none-win32.whl
lxml-3.5.0-cp35-none-win_amd64.whl
</code></pre><p>cp后面是Python的版本号，27表示2.7，amd64表示64位系统，根据你的Python版本选择下载。</p>
</li>
<li>进入.whl所在的文件夹，执行命令即可完成安装<code>pip install 带后缀的完整文件名</code></li>
</ol>
<h3 id="matplotlib安装"><a href="#matplotlib安装" class="headerlink" title="matplotlib安装"></a>matplotlib安装</h3><p>参考链接 ： </p>
<ol>
<li><a href="http://matplotlib.org/users/installing.html" target="_blank" rel="external">官方文档</a></li>
</ol>
<p><strong> Build requirements </strong><br>These are external packages which you will need to install before installing matplotlib.</p>
<p>If you are installing dependencies with a package manager on Linux, you may need to install the development packages (look for a “-de”” postf) in addition to the librari themselves</p>
<h4 id="Building-on-Linux"><a href="#Building-on-Linux" class="headerlink" title="Building on Linux"></a>Building on Linux</h4><p>It is easiest to use your system package manager to install the dependencies.</p>
<p>If you are on Debian/Ubuntu, you can get all the dependencies required to build matplotlib with:</p>
<pre><code>sudo apt-get build-dep python-matplotlib
</code></pre><p>This does not build matplotlib, but it does get the install the build dependencies, which will make building from source easier.</p>
<p>然后使用pip install matplotlib即可</p>
<h4 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h4><p>I had the same issue, and installing matplotlib using easy_install instead of pip did not solve it. In the end, I found out that the problem was simply that matplotlib could not find any backend for plotting.</p>
<p>I solved it by doing the following (I am using Debian wheezy):</p>
<pre><code>pip uninstall matplotlib
sudo apt-get install tcl-dev tk-dev
pip install matplotlib
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	

	
    		
    
      <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ubuntu下git-status的中文乱码解决"><span class="toc-number">1.</span> <span class="toc-text">ubuntu下git status的中文乱码解决</span></a></li></ol>
</div>

      
  

      
<article class="post">
  
  <div class="post-content">
    <header>
        <div class="icon"></div>
        
        <time datetime="2016-01-14T16:05:09.000Z"><a href="/hexo_blog/2016/01/15/Git-2016-01-15-git-common-issue/">2016-01-15</a></time>
        
  
    <h1 class="title"><a href="/hexo_blog/2016/01/15/Git-2016-01-15-git-common-issue/">Git~常见问题</a></h1>
  

    </header>

    <div class="entry">
      
          <!--
       
              <div class="openaside"><a class="navbutton" href="#" title="显示目录"></a></div>
<div id="toc" class="toc-aside">
  <strong class="toc-title"> 目录 </strong>
  <strong class="toc-title"> undefined </strong>
<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ubuntu下git-status的中文乱码解决"><span class="toc-number">1.</span> <span class="toc-text">ubuntu下git status的中文乱码解决</span></a></li></ol>
</div>

                  

                  -->
        <h3 id="ubuntu下git-status的中文乱码解决"><a href="#ubuntu下git-status的中文乱码解决" class="headerlink" title="ubuntu下git status的中文乱码解决"></a>ubuntu下git status的中文乱码解决</h3><p>只要一行就行了</p>
<pre><code>git config --global core.quotepath false
</code></pre><p>对比效果图<br><img src="/hexo_blog/images/Git/git-status-chinese-messy.jpg" alt="git-status-chinese-messy"></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



    	
 
<nav id="pagination">
  
    <a href="/hexo_blog/page/6/" class="alignleft prev">上一页</a>
  
  
    <a href="/hexo_blog/page/8/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav>
</div></div>
        <aside id="sidebar" class="alignright">

   <div class="search">
  <form action="//baidu.com/s" method="get" accept-charset="utf-8">
    <input type="search" name="wd"results="0" placeholder="搜索">
    <input type="hidden" name="wd" value="site:ywlbupt.github.com/hexo_blog">
  </form>
</div> 


  
<div class="widget tag">
  <h3 class="title" id="categories">分类</h3>
<!--   
	
		<li><a class = "list-2"href="/hexo_blog/categories/Ubuntu/Basic/">Basic</a><small>2</small></li>
     
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/Python/Basic/">Basic</a><small>10</small></li>
     
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/Ubuntu/Cmd/">Cmd</a><small>8</small></li>
     
  
	
		<li><a href="/hexo_blog/categories/Diary/">Diary</a><small>1</small></li>
	
  
	
		<li><a href="/hexo_blog/categories/Gallery/">Gallery</a><small>1</small></li>
	
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/Iterator/Generator/">Generator</a><small>1</small></li>
     
  
	
		<li><a href="/hexo_blog/categories/Git/">Git</a><small>1</small></li>
	
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/Markdown/Hexo/">Hexo</a><small>3</small></li>
     
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/Ubuntu/IDE/">IDE</a><small>3</small></li>
     
  
	
		<li><a href="/hexo_blog/categories/Iterator/">Iterator</a><small>1</small></li>
	
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/Python/Lib/">Lib</a><small>5</small></li>
     
  
	
		<li><a href="/hexo_blog/categories/Markdown/">Markdown</a><small>3</small></li>
	
  
	
		<li><a href="/hexo_blog/categories/Network/">Network</a><small>1</small></li>
	
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/Vim/Plugin/">Plugin</a><small>2</small></li>
     
  
	
		<li><a href="/hexo_blog/categories/Python/">Python</a><small>18</small></li>
	
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/Python/Python-Basic/">Python_Basic</a><small>2</small></li>
     
  
	
		<li><a href="/hexo_blog/categories/Raspberry/">Raspberry</a><small>1</small></li>
	
  
	
		<li><a href="/hexo_blog/categories/SQL/">SQL</a><small>2</small></li>
	
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/Network/SSH/">SSH</a><small>1</small></li>
     
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/SQL/Sqlite3/">Sqlite3</a><small>2</small></li>
     
  
	
		<li><a href="/hexo_blog/categories/Ubuntu/">Ubuntu</a><small>13</small></li>
	
  
	
		<li><a href="/hexo_blog/categories/Vim/">Vim</a><small>3</small></li>
	
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/python/basic/">basic</a><small>2</small></li>
     
  
	
		<li><a href="/hexo_blog/categories/isinstance/">isinstance</a><small>1</small></li>
	
  
	
		<li><a href="/hexo_blog/categories/python/">python</a><small>2</small></li>
	
  
	
		<li><a class = "list-2"href="/hexo_blog/categories/isinstance/type/">type</a><small>1</small></li>
     
   -->


     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Diary/">Diary</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Gallery/">Gallery</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Iterator/">Iterator</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Iterator/Generator/">Generator</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Markdown/">Markdown</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Markdown/Hexo/">Hexo</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Network/">Network</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Network/SSH/">SSH</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Python/">Python</a><span class="category-list-count">18</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Python/Basic/">Basic</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Python/Lib/">Lib</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Python/Python-Basic/">Python_Basic</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Raspberry/">Raspberry</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/SQL/">SQL</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/SQL/Sqlite3/">Sqlite3</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Ubuntu/">Ubuntu</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Ubuntu/Basic/">Basic</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Ubuntu/Cmd/">Cmd</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Ubuntu/IDE/">IDE</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Vim/">Vim</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/Vim/Plugin/">Plugin</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/isinstance/">isinstance</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/isinstance/type/">type</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/python/">python</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexo_blog/categories/python/basic/">basic</a><span class="category-list-count">2</span></li></ul></li></ul> 
</div>
 


  <div class="widget tag">
  <h3 class="title">日历云</h3>
  <div id="calendar"></div>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/hexo_blog/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/hexo_blog/tags/Zhihu/" style="font-size: 10px;">Zhihu</a> <a href="/hexo_blog/tags/ansible/" style="font-size: 10px;">ansible</a> <a href="/hexo_blog/tags/cmd/" style="font-size: 10px;">cmd</a> <a href="/hexo_blog/tags/codecs/" style="font-size: 10px;">codecs</a> <a href="/hexo_blog/tags/const/" style="font-size: 10px;">const</a> <a href="/hexo_blog/tags/dd/" style="font-size: 10px;">dd</a> <a href="/hexo_blog/tags/deb/" style="font-size: 10px;">deb</a> <a href="/hexo_blog/tags/df/" style="font-size: 10px;">df</a> <a href="/hexo_blog/tags/ejs引擎/" style="font-size: 10px;">ejs引擎</a> <a href="/hexo_blog/tags/escape/" style="font-size: 10px;">escape</a> <a href="/hexo_blog/tags/fdisk/" style="font-size: 10px;">fdisk</a> <a href="/hexo_blog/tags/find/" style="font-size: 10px;">find</a> <a href="/hexo_blog/tags/git/" style="font-size: 16.67px;">git</a> <a href="/hexo_blog/tags/grep/" style="font-size: 10px;">grep</a> <a href="/hexo_blog/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/hexo_blog/tags/hosts/" style="font-size: 10px;">hosts</a> <a href="/hexo_blog/tags/jacman/" style="font-size: 13.33px;">jacman</a> <a href="/hexo_blog/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/hexo_blog/tags/json/" style="font-size: 10px;">json</a> <a href="/hexo_blog/tags/object/" style="font-size: 10px;">object</a> <a href="/hexo_blog/tags/os/" style="font-size: 10px;">os</a> <a href="/hexo_blog/tags/python/" style="font-size: 20px;">python</a> <a href="/hexo_blog/tags/shutdown/" style="font-size: 10px;">shutdown</a> <a href="/hexo_blog/tags/snippets/" style="font-size: 10px;">snippets</a> <a href="/hexo_blog/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/hexo_blog/tags/string/" style="font-size: 10px;">string</a> <a href="/hexo_blog/tags/tmux/" style="font-size: 10px;">tmux</a> <a href="/hexo_blog/tags/tutorial/" style="font-size: 10px;">tutorial</a> <a href="/hexo_blog/tags/type/" style="font-size: 10px;">type</a> <a href="/hexo_blog/tags/vim/" style="font-size: 13.33px;">vim</a> <a href="/hexo_blog/tags/wrapper/" style="font-size: 10px;">wrapper</a> <a href="/hexo_blog/tags/yaml/" style="font-size: 10px;">yaml</a> <a href="/hexo_blog/tags/zt/" style="font-size: 10px;">zt</a> <a href="/hexo_blog/tags/人工置顶/" style="font-size: 10px;">人工置顶</a> <a href="/hexo_blog/tags/科学上网/" style="font-size: 10px;">科学上网</a>
  </div>
</div>


</aside>

      <div class="clearfix"></div>
    </div>
  
  <footer id="footer"><div class="footer-content inner">
  <div class="alignleft">
  
    &copy; 2017 Wlin
    
  </div>
  <div class="alignright">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme
    <a href="https://github.com/pengloo53/Hexo-theme-light_cn">light_cn</a>
  </div>
  
  <div class="visit">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </div>
  
  <div class="clearfix"></div>
</div></footer>
  <script src="http://libs.baidu.com/jquery/2.1.1/jquery.min.js"></script>
<script src="/hexo_blog/js/jquery.imagesloaded.min.js"></script>
<script src="/hexo_blog/js/gallery.js"></script>

<!-- add calendar widget -->

  <script src="/hexo_blog/js/calendar.js"></script>
  <script src="/hexo_blog/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:undefined, root:'calendar'});
    
    });
  </script>


<!-- 添加『不蒜子』计数服务 -->
<script async src="http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>


<!-- 目录与分类的切换按钮 -->
<script type="text/javascript">
$(document).ready(function(){ 
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#sidebar'),
      c = $('.closeaside'),
      o = $('.openaside');
      t = $('#toc.toc-aside')
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    // t.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    t.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>



</body>
</html>


